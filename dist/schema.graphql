# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateAssertion {
  _avg: AssertionAvgAggregate
  _count: AssertionCountAggregate
  _max: AssertionMaxAggregate
  _min: AssertionMinAggregate
  _sum: AssertionSumAggregate
}

type AggregateCollection {
  _avg: CollectionAvgAggregate
  _count: CollectionCountAggregate
  _max: CollectionMaxAggregate
  _min: CollectionMinAggregate
  _sum: CollectionSumAggregate
}

type AggregateCollectionRun {
  _avg: CollectionRunAvgAggregate
  _count: CollectionRunCountAggregate
  _max: CollectionRunMaxAggregate
  _min: CollectionRunMinAggregate
  _sum: CollectionRunSumAggregate
}

type AggregateMonitor {
  _avg: MonitorAvgAggregate
  _count: MonitorCountAggregate
  _max: MonitorMaxAggregate
  _min: MonitorMinAggregate
  _sum: MonitorSumAggregate
}

type AggregateRequest {
  _avg: RequestAvgAggregate
  _count: RequestCountAggregate
  _max: RequestMaxAggregate
  _min: RequestMinAggregate
  _sum: RequestSumAggregate
}

type AggregateResponse {
  _avg: ResponseAvgAggregate
  _count: ResponseCountAggregate
  _max: ResponseMaxAggregate
  _min: ResponseMinAggregate
  _sum: ResponseSumAggregate
}

type Assertion {
  actual: String
  createdAt: DateTime!
  expected: String!
  id: Int!
  property: String!
  request: Request!
  requestId: Int!
}

type AssertionAvgAggregate {
  id: Float
  requestId: Float
}

input AssertionAvgOrderByAggregateInput {
  id: SortOrder
  requestId: SortOrder
}

type AssertionCountAggregate {
  _all: Int!
  actual: Int!
  createdAt: Int!
  expected: Int!
  id: Int!
  property: Int!
  requestId: Int!
}

input AssertionCountOrderByAggregateInput {
  actual: SortOrder
  createdAt: SortOrder
  expected: SortOrder
  id: SortOrder
  property: SortOrder
  requestId: SortOrder
}

input AssertionCreateInput {
  actual: String
  createdAt: DateTime
  expected: String!
  property: String!
  request: RequestCreateNestedOneWithoutAssertionsInput!
}

input AssertionCreateManyInput {
  actual: String
  createdAt: DateTime
  expected: String!
  id: Int
  property: String!
  requestId: Int!
}

input AssertionCreateManyRequestInput {
  actual: String
  createdAt: DateTime
  expected: String!
  id: Int
  property: String!
}

input AssertionCreateManyRequestInputEnvelope {
  data: [AssertionCreateManyRequestInput!]!
  skipDuplicates: Boolean
}

input AssertionCreateNestedManyWithoutRequestInput {
  connect: [AssertionWhereUniqueInput!]
  connectOrCreate: [AssertionCreateOrConnectWithoutRequestInput!]
  create: [AssertionCreateWithoutRequestInput!]
  createMany: AssertionCreateManyRequestInputEnvelope
}

input AssertionCreateOrConnectWithoutRequestInput {
  create: AssertionCreateWithoutRequestInput!
  where: AssertionWhereUniqueInput!
}

input AssertionCreateWithoutRequestInput {
  actual: String
  createdAt: DateTime
  expected: String!
  property: String!
}

type AssertionGroupBy {
  _avg: AssertionAvgAggregate
  _count: AssertionCountAggregate
  _max: AssertionMaxAggregate
  _min: AssertionMinAggregate
  _sum: AssertionSumAggregate
  actual: String
  createdAt: DateTime!
  expected: String!
  id: Int!
  property: String!
  requestId: Int!
}

input AssertionListRelationFilter {
  every: AssertionWhereInput
  none: AssertionWhereInput
  some: AssertionWhereInput
}

type AssertionMaxAggregate {
  actual: String
  createdAt: DateTime
  expected: String
  id: Int
  property: String
  requestId: Int
}

input AssertionMaxOrderByAggregateInput {
  actual: SortOrder
  createdAt: SortOrder
  expected: SortOrder
  id: SortOrder
  property: SortOrder
  requestId: SortOrder
}

type AssertionMinAggregate {
  actual: String
  createdAt: DateTime
  expected: String
  id: Int
  property: String
  requestId: Int
}

input AssertionMinOrderByAggregateInput {
  actual: SortOrder
  createdAt: SortOrder
  expected: SortOrder
  id: SortOrder
  property: SortOrder
  requestId: SortOrder
}

input AssertionOrderByRelationAggregateInput {
  _count: SortOrder
}

input AssertionOrderByWithAggregationInput {
  _avg: AssertionAvgOrderByAggregateInput
  _count: AssertionCountOrderByAggregateInput
  _max: AssertionMaxOrderByAggregateInput
  _min: AssertionMinOrderByAggregateInput
  _sum: AssertionSumOrderByAggregateInput
  actual: SortOrder
  createdAt: SortOrder
  expected: SortOrder
  id: SortOrder
  property: SortOrder
  requestId: SortOrder
}

input AssertionOrderByWithRelationInput {
  actual: SortOrder
  createdAt: SortOrder
  expected: SortOrder
  id: SortOrder
  property: SortOrder
  request: RequestOrderByWithRelationInput
  requestId: SortOrder
}

enum AssertionScalarFieldEnum {
  actual
  createdAt
  expected
  id
  property
  requestId
}

input AssertionScalarWhereInput {
  AND: [AssertionScalarWhereInput!]
  NOT: [AssertionScalarWhereInput!]
  OR: [AssertionScalarWhereInput!]
  actual: StringNullableFilter
  createdAt: DateTimeFilter
  expected: StringFilter
  id: IntFilter
  property: StringFilter
  requestId: IntFilter
}

input AssertionScalarWhereWithAggregatesInput {
  AND: [AssertionScalarWhereWithAggregatesInput!]
  NOT: [AssertionScalarWhereWithAggregatesInput!]
  OR: [AssertionScalarWhereWithAggregatesInput!]
  actual: StringNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  expected: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  property: StringWithAggregatesFilter
  requestId: IntWithAggregatesFilter
}

type AssertionSumAggregate {
  id: Int
  requestId: Int
}

input AssertionSumOrderByAggregateInput {
  id: SortOrder
  requestId: SortOrder
}

input AssertionUpdateInput {
  actual: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  expected: StringFieldUpdateOperationsInput
  property: StringFieldUpdateOperationsInput
  request: RequestUpdateOneRequiredWithoutAssertionsNestedInput
}

input AssertionUpdateManyMutationInput {
  actual: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  expected: StringFieldUpdateOperationsInput
  property: StringFieldUpdateOperationsInput
}

input AssertionUpdateManyWithWhereWithoutRequestInput {
  data: AssertionUpdateManyMutationInput!
  where: AssertionScalarWhereInput!
}

input AssertionUpdateManyWithoutRequestNestedInput {
  connect: [AssertionWhereUniqueInput!]
  connectOrCreate: [AssertionCreateOrConnectWithoutRequestInput!]
  create: [AssertionCreateWithoutRequestInput!]
  createMany: AssertionCreateManyRequestInputEnvelope
  delete: [AssertionWhereUniqueInput!]
  deleteMany: [AssertionScalarWhereInput!]
  disconnect: [AssertionWhereUniqueInput!]
  set: [AssertionWhereUniqueInput!]
  update: [AssertionUpdateWithWhereUniqueWithoutRequestInput!]
  updateMany: [AssertionUpdateManyWithWhereWithoutRequestInput!]
  upsert: [AssertionUpsertWithWhereUniqueWithoutRequestInput!]
}

input AssertionUpdateWithWhereUniqueWithoutRequestInput {
  data: AssertionUpdateWithoutRequestInput!
  where: AssertionWhereUniqueInput!
}

input AssertionUpdateWithoutRequestInput {
  actual: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  expected: StringFieldUpdateOperationsInput
  property: StringFieldUpdateOperationsInput
}

input AssertionUpsertWithWhereUniqueWithoutRequestInput {
  create: AssertionCreateWithoutRequestInput!
  update: AssertionUpdateWithoutRequestInput!
  where: AssertionWhereUniqueInput!
}

input AssertionWhereInput {
  AND: [AssertionWhereInput!]
  NOT: [AssertionWhereInput!]
  OR: [AssertionWhereInput!]
  actual: StringNullableFilter
  createdAt: DateTimeFilter
  expected: StringFilter
  id: IntFilter
  property: StringFilter
  request: RequestRelationFilter
  requestId: IntFilter
}

input AssertionWhereUniqueInput {
  id: Int
}

type Collection {
  CollectionRun(cursor: CollectionRunWhereUniqueInput, distinct: [CollectionRunScalarFieldEnum!], orderBy: [CollectionRunOrderByWithRelationInput!], skip: Int, take: Int, where: CollectionRunWhereInput): [CollectionRun!]!
  Monitor(cursor: MonitorWhereUniqueInput, distinct: [MonitorScalarFieldEnum!], orderBy: [MonitorOrderByWithRelationInput!], skip: Int, take: Int, where: MonitorWhereInput): [Monitor!]!
  _count: CollectionCount
  createdAt: DateTime!
  id: Int!
  requests(cursor: RequestWhereUniqueInput, distinct: [RequestScalarFieldEnum!], orderBy: [RequestOrderByWithRelationInput!], skip: Int, take: Int, where: RequestWhereInput): [Request!]!
  title: String!
}

type CollectionAvgAggregate {
  id: Float
}

input CollectionAvgOrderByAggregateInput {
  id: SortOrder
}

type CollectionCount {
  CollectionRun: Int!
  Monitor: Int!
  requests: Int!
}

type CollectionCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  title: Int!
}

input CollectionCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  title: SortOrder
}

input CollectionCreateInput {
  CollectionRun: CollectionRunCreateNestedManyWithoutCollectionInput
  Monitor: MonitorCreateNestedManyWithoutCollectionInput
  createdAt: DateTime
  requests: RequestCreateNestedManyWithoutCollectionInput
  title: String!
}

input CollectionCreateManyInput {
  createdAt: DateTime
  id: Int
  title: String!
}

input CollectionCreateNestedOneWithoutCollectionRunInput {
  connect: CollectionWhereUniqueInput
  connectOrCreate: CollectionCreateOrConnectWithoutCollectionRunInput
  create: CollectionCreateWithoutCollectionRunInput
}

input CollectionCreateNestedOneWithoutMonitorInput {
  connect: CollectionWhereUniqueInput
  connectOrCreate: CollectionCreateOrConnectWithoutMonitorInput
  create: CollectionCreateWithoutMonitorInput
}

input CollectionCreateNestedOneWithoutRequestsInput {
  connect: CollectionWhereUniqueInput
  connectOrCreate: CollectionCreateOrConnectWithoutRequestsInput
  create: CollectionCreateWithoutRequestsInput
}

input CollectionCreateOrConnectWithoutCollectionRunInput {
  create: CollectionCreateWithoutCollectionRunInput!
  where: CollectionWhereUniqueInput!
}

input CollectionCreateOrConnectWithoutMonitorInput {
  create: CollectionCreateWithoutMonitorInput!
  where: CollectionWhereUniqueInput!
}

input CollectionCreateOrConnectWithoutRequestsInput {
  create: CollectionCreateWithoutRequestsInput!
  where: CollectionWhereUniqueInput!
}

input CollectionCreateWithoutCollectionRunInput {
  Monitor: MonitorCreateNestedManyWithoutCollectionInput
  createdAt: DateTime
  requests: RequestCreateNestedManyWithoutCollectionInput
  title: String!
}

input CollectionCreateWithoutMonitorInput {
  CollectionRun: CollectionRunCreateNestedManyWithoutCollectionInput
  createdAt: DateTime
  requests: RequestCreateNestedManyWithoutCollectionInput
  title: String!
}

input CollectionCreateWithoutRequestsInput {
  CollectionRun: CollectionRunCreateNestedManyWithoutCollectionInput
  Monitor: MonitorCreateNestedManyWithoutCollectionInput
  createdAt: DateTime
  title: String!
}

type CollectionGroupBy {
  _avg: CollectionAvgAggregate
  _count: CollectionCountAggregate
  _max: CollectionMaxAggregate
  _min: CollectionMinAggregate
  _sum: CollectionSumAggregate
  createdAt: DateTime!
  id: Int!
  title: String!
}

type CollectionMaxAggregate {
  createdAt: DateTime
  id: Int
  title: String
}

input CollectionMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  title: SortOrder
}

type CollectionMinAggregate {
  createdAt: DateTime
  id: Int
  title: String
}

input CollectionMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  title: SortOrder
}

input CollectionOrderByWithAggregationInput {
  _avg: CollectionAvgOrderByAggregateInput
  _count: CollectionCountOrderByAggregateInput
  _max: CollectionMaxOrderByAggregateInput
  _min: CollectionMinOrderByAggregateInput
  _sum: CollectionSumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  title: SortOrder
}

input CollectionOrderByWithRelationInput {
  CollectionRun: CollectionRunOrderByRelationAggregateInput
  Monitor: MonitorOrderByRelationAggregateInput
  createdAt: SortOrder
  id: SortOrder
  requests: RequestOrderByRelationAggregateInput
  title: SortOrder
}

input CollectionRelationFilter {
  is: CollectionWhereInput
  isNot: CollectionWhereInput
}

type CollectionRun {
  collection: Collection!
  collectionId: Int!
  createdAt: DateTime!
  finishedAt: DateTime!
  id: Int!
  monitor: Monitor!
  monitorId: Int!
  startedAt: DateTime!
}

type CollectionRunAvgAggregate {
  collectionId: Float
  id: Float
  monitorId: Float
}

input CollectionRunAvgOrderByAggregateInput {
  collectionId: SortOrder
  id: SortOrder
  monitorId: SortOrder
}

type CollectionRunCountAggregate {
  _all: Int!
  collectionId: Int!
  createdAt: Int!
  finishedAt: Int!
  id: Int!
  monitorId: Int!
  startedAt: Int!
}

input CollectionRunCountOrderByAggregateInput {
  collectionId: SortOrder
  createdAt: SortOrder
  finishedAt: SortOrder
  id: SortOrder
  monitorId: SortOrder
  startedAt: SortOrder
}

input CollectionRunCreateInput {
  collection: CollectionCreateNestedOneWithoutCollectionRunInput!
  createdAt: DateTime
  finishedAt: DateTime!
  monitor: MonitorCreateNestedOneWithoutCollectionRunsInput!
  startedAt: DateTime!
}

input CollectionRunCreateManyCollectionInput {
  createdAt: DateTime
  finishedAt: DateTime!
  id: Int
  monitorId: Int!
  startedAt: DateTime!
}

input CollectionRunCreateManyCollectionInputEnvelope {
  data: [CollectionRunCreateManyCollectionInput!]!
  skipDuplicates: Boolean
}

input CollectionRunCreateManyInput {
  collectionId: Int!
  createdAt: DateTime
  finishedAt: DateTime!
  id: Int
  monitorId: Int!
  startedAt: DateTime!
}

input CollectionRunCreateManyMonitorInput {
  collectionId: Int!
  createdAt: DateTime
  finishedAt: DateTime!
  id: Int
  startedAt: DateTime!
}

input CollectionRunCreateManyMonitorInputEnvelope {
  data: [CollectionRunCreateManyMonitorInput!]!
  skipDuplicates: Boolean
}

input CollectionRunCreateNestedManyWithoutCollectionInput {
  connect: [CollectionRunWhereUniqueInput!]
  connectOrCreate: [CollectionRunCreateOrConnectWithoutCollectionInput!]
  create: [CollectionRunCreateWithoutCollectionInput!]
  createMany: CollectionRunCreateManyCollectionInputEnvelope
}

input CollectionRunCreateNestedManyWithoutMonitorInput {
  connect: [CollectionRunWhereUniqueInput!]
  connectOrCreate: [CollectionRunCreateOrConnectWithoutMonitorInput!]
  create: [CollectionRunCreateWithoutMonitorInput!]
  createMany: CollectionRunCreateManyMonitorInputEnvelope
}

input CollectionRunCreateOrConnectWithoutCollectionInput {
  create: CollectionRunCreateWithoutCollectionInput!
  where: CollectionRunWhereUniqueInput!
}

input CollectionRunCreateOrConnectWithoutMonitorInput {
  create: CollectionRunCreateWithoutMonitorInput!
  where: CollectionRunWhereUniqueInput!
}

input CollectionRunCreateWithoutCollectionInput {
  createdAt: DateTime
  finishedAt: DateTime!
  monitor: MonitorCreateNestedOneWithoutCollectionRunsInput!
  startedAt: DateTime!
}

input CollectionRunCreateWithoutMonitorInput {
  collection: CollectionCreateNestedOneWithoutCollectionRunInput!
  createdAt: DateTime
  finishedAt: DateTime!
  startedAt: DateTime!
}

type CollectionRunGroupBy {
  _avg: CollectionRunAvgAggregate
  _count: CollectionRunCountAggregate
  _max: CollectionRunMaxAggregate
  _min: CollectionRunMinAggregate
  _sum: CollectionRunSumAggregate
  collectionId: Int!
  createdAt: DateTime!
  finishedAt: DateTime!
  id: Int!
  monitorId: Int!
  startedAt: DateTime!
}

input CollectionRunListRelationFilter {
  every: CollectionRunWhereInput
  none: CollectionRunWhereInput
  some: CollectionRunWhereInput
}

type CollectionRunMaxAggregate {
  collectionId: Int
  createdAt: DateTime
  finishedAt: DateTime
  id: Int
  monitorId: Int
  startedAt: DateTime
}

input CollectionRunMaxOrderByAggregateInput {
  collectionId: SortOrder
  createdAt: SortOrder
  finishedAt: SortOrder
  id: SortOrder
  monitorId: SortOrder
  startedAt: SortOrder
}

type CollectionRunMinAggregate {
  collectionId: Int
  createdAt: DateTime
  finishedAt: DateTime
  id: Int
  monitorId: Int
  startedAt: DateTime
}

input CollectionRunMinOrderByAggregateInput {
  collectionId: SortOrder
  createdAt: SortOrder
  finishedAt: SortOrder
  id: SortOrder
  monitorId: SortOrder
  startedAt: SortOrder
}

input CollectionRunOrderByRelationAggregateInput {
  _count: SortOrder
}

input CollectionRunOrderByWithAggregationInput {
  _avg: CollectionRunAvgOrderByAggregateInput
  _count: CollectionRunCountOrderByAggregateInput
  _max: CollectionRunMaxOrderByAggregateInput
  _min: CollectionRunMinOrderByAggregateInput
  _sum: CollectionRunSumOrderByAggregateInput
  collectionId: SortOrder
  createdAt: SortOrder
  finishedAt: SortOrder
  id: SortOrder
  monitorId: SortOrder
  startedAt: SortOrder
}

input CollectionRunOrderByWithRelationInput {
  collection: CollectionOrderByWithRelationInput
  collectionId: SortOrder
  createdAt: SortOrder
  finishedAt: SortOrder
  id: SortOrder
  monitor: MonitorOrderByWithRelationInput
  monitorId: SortOrder
  startedAt: SortOrder
}

enum CollectionRunScalarFieldEnum {
  collectionId
  createdAt
  finishedAt
  id
  monitorId
  startedAt
}

input CollectionRunScalarWhereInput {
  AND: [CollectionRunScalarWhereInput!]
  NOT: [CollectionRunScalarWhereInput!]
  OR: [CollectionRunScalarWhereInput!]
  collectionId: IntFilter
  createdAt: DateTimeFilter
  finishedAt: DateTimeFilter
  id: IntFilter
  monitorId: IntFilter
  startedAt: DateTimeFilter
}

input CollectionRunScalarWhereWithAggregatesInput {
  AND: [CollectionRunScalarWhereWithAggregatesInput!]
  NOT: [CollectionRunScalarWhereWithAggregatesInput!]
  OR: [CollectionRunScalarWhereWithAggregatesInput!]
  collectionId: IntWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  finishedAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  monitorId: IntWithAggregatesFilter
  startedAt: DateTimeWithAggregatesFilter
}

type CollectionRunSumAggregate {
  collectionId: Int
  id: Int
  monitorId: Int
}

input CollectionRunSumOrderByAggregateInput {
  collectionId: SortOrder
  id: SortOrder
  monitorId: SortOrder
}

input CollectionRunUpdateInput {
  collection: CollectionUpdateOneRequiredWithoutCollectionRunNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  finishedAt: DateTimeFieldUpdateOperationsInput
  monitor: MonitorUpdateOneRequiredWithoutCollectionRunsNestedInput
  startedAt: DateTimeFieldUpdateOperationsInput
}

input CollectionRunUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  finishedAt: DateTimeFieldUpdateOperationsInput
  startedAt: DateTimeFieldUpdateOperationsInput
}

input CollectionRunUpdateManyWithWhereWithoutCollectionInput {
  data: CollectionRunUpdateManyMutationInput!
  where: CollectionRunScalarWhereInput!
}

input CollectionRunUpdateManyWithWhereWithoutMonitorInput {
  data: CollectionRunUpdateManyMutationInput!
  where: CollectionRunScalarWhereInput!
}

input CollectionRunUpdateManyWithoutCollectionNestedInput {
  connect: [CollectionRunWhereUniqueInput!]
  connectOrCreate: [CollectionRunCreateOrConnectWithoutCollectionInput!]
  create: [CollectionRunCreateWithoutCollectionInput!]
  createMany: CollectionRunCreateManyCollectionInputEnvelope
  delete: [CollectionRunWhereUniqueInput!]
  deleteMany: [CollectionRunScalarWhereInput!]
  disconnect: [CollectionRunWhereUniqueInput!]
  set: [CollectionRunWhereUniqueInput!]
  update: [CollectionRunUpdateWithWhereUniqueWithoutCollectionInput!]
  updateMany: [CollectionRunUpdateManyWithWhereWithoutCollectionInput!]
  upsert: [CollectionRunUpsertWithWhereUniqueWithoutCollectionInput!]
}

input CollectionRunUpdateManyWithoutMonitorNestedInput {
  connect: [CollectionRunWhereUniqueInput!]
  connectOrCreate: [CollectionRunCreateOrConnectWithoutMonitorInput!]
  create: [CollectionRunCreateWithoutMonitorInput!]
  createMany: CollectionRunCreateManyMonitorInputEnvelope
  delete: [CollectionRunWhereUniqueInput!]
  deleteMany: [CollectionRunScalarWhereInput!]
  disconnect: [CollectionRunWhereUniqueInput!]
  set: [CollectionRunWhereUniqueInput!]
  update: [CollectionRunUpdateWithWhereUniqueWithoutMonitorInput!]
  updateMany: [CollectionRunUpdateManyWithWhereWithoutMonitorInput!]
  upsert: [CollectionRunUpsertWithWhereUniqueWithoutMonitorInput!]
}

input CollectionRunUpdateWithWhereUniqueWithoutCollectionInput {
  data: CollectionRunUpdateWithoutCollectionInput!
  where: CollectionRunWhereUniqueInput!
}

input CollectionRunUpdateWithWhereUniqueWithoutMonitorInput {
  data: CollectionRunUpdateWithoutMonitorInput!
  where: CollectionRunWhereUniqueInput!
}

input CollectionRunUpdateWithoutCollectionInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  finishedAt: DateTimeFieldUpdateOperationsInput
  monitor: MonitorUpdateOneRequiredWithoutCollectionRunsNestedInput
  startedAt: DateTimeFieldUpdateOperationsInput
}

input CollectionRunUpdateWithoutMonitorInput {
  collection: CollectionUpdateOneRequiredWithoutCollectionRunNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  finishedAt: DateTimeFieldUpdateOperationsInput
  startedAt: DateTimeFieldUpdateOperationsInput
}

input CollectionRunUpsertWithWhereUniqueWithoutCollectionInput {
  create: CollectionRunCreateWithoutCollectionInput!
  update: CollectionRunUpdateWithoutCollectionInput!
  where: CollectionRunWhereUniqueInput!
}

input CollectionRunUpsertWithWhereUniqueWithoutMonitorInput {
  create: CollectionRunCreateWithoutMonitorInput!
  update: CollectionRunUpdateWithoutMonitorInput!
  where: CollectionRunWhereUniqueInput!
}

input CollectionRunWhereInput {
  AND: [CollectionRunWhereInput!]
  NOT: [CollectionRunWhereInput!]
  OR: [CollectionRunWhereInput!]
  collection: CollectionRelationFilter
  collectionId: IntFilter
  createdAt: DateTimeFilter
  finishedAt: DateTimeFilter
  id: IntFilter
  monitor: MonitorRelationFilter
  monitorId: IntFilter
  startedAt: DateTimeFilter
}

input CollectionRunWhereUniqueInput {
  id: Int
}

enum CollectionScalarFieldEnum {
  createdAt
  id
  title
}

input CollectionScalarWhereWithAggregatesInput {
  AND: [CollectionScalarWhereWithAggregatesInput!]
  NOT: [CollectionScalarWhereWithAggregatesInput!]
  OR: [CollectionScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  title: StringWithAggregatesFilter
}

type CollectionSumAggregate {
  id: Int
}

input CollectionSumOrderByAggregateInput {
  id: SortOrder
}

input CollectionUpdateInput {
  CollectionRun: CollectionRunUpdateManyWithoutCollectionNestedInput
  Monitor: MonitorUpdateManyWithoutCollectionNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  requests: RequestUpdateManyWithoutCollectionNestedInput
  title: StringFieldUpdateOperationsInput
}

input CollectionUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input CollectionUpdateOneRequiredWithoutCollectionRunNestedInput {
  connect: CollectionWhereUniqueInput
  connectOrCreate: CollectionCreateOrConnectWithoutCollectionRunInput
  create: CollectionCreateWithoutCollectionRunInput
  update: CollectionUpdateWithoutCollectionRunInput
  upsert: CollectionUpsertWithoutCollectionRunInput
}

input CollectionUpdateOneRequiredWithoutMonitorNestedInput {
  connect: CollectionWhereUniqueInput
  connectOrCreate: CollectionCreateOrConnectWithoutMonitorInput
  create: CollectionCreateWithoutMonitorInput
  update: CollectionUpdateWithoutMonitorInput
  upsert: CollectionUpsertWithoutMonitorInput
}

input CollectionUpdateOneRequiredWithoutRequestsNestedInput {
  connect: CollectionWhereUniqueInput
  connectOrCreate: CollectionCreateOrConnectWithoutRequestsInput
  create: CollectionCreateWithoutRequestsInput
  update: CollectionUpdateWithoutRequestsInput
  upsert: CollectionUpsertWithoutRequestsInput
}

input CollectionUpdateWithoutCollectionRunInput {
  Monitor: MonitorUpdateManyWithoutCollectionNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  requests: RequestUpdateManyWithoutCollectionNestedInput
  title: StringFieldUpdateOperationsInput
}

input CollectionUpdateWithoutMonitorInput {
  CollectionRun: CollectionRunUpdateManyWithoutCollectionNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  requests: RequestUpdateManyWithoutCollectionNestedInput
  title: StringFieldUpdateOperationsInput
}

input CollectionUpdateWithoutRequestsInput {
  CollectionRun: CollectionRunUpdateManyWithoutCollectionNestedInput
  Monitor: MonitorUpdateManyWithoutCollectionNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input CollectionUpsertWithoutCollectionRunInput {
  create: CollectionCreateWithoutCollectionRunInput!
  update: CollectionUpdateWithoutCollectionRunInput!
}

input CollectionUpsertWithoutMonitorInput {
  create: CollectionCreateWithoutMonitorInput!
  update: CollectionUpdateWithoutMonitorInput!
}

input CollectionUpsertWithoutRequestsInput {
  create: CollectionCreateWithoutRequestsInput!
  update: CollectionUpdateWithoutRequestsInput!
}

input CollectionWhereInput {
  AND: [CollectionWhereInput!]
  CollectionRun: CollectionRunListRelationFilter
  Monitor: MonitorListRelationFilter
  NOT: [CollectionWhereInput!]
  OR: [CollectionWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  requests: RequestListRelationFilter
  title: StringFilter
}

input CollectionWhereUniqueInput {
  id: Int
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

input JsonFilter {
  array_contains: JSON
  array_ends_with: JSON
  array_starts_with: JSON
  equals: JSON
  gt: JSON
  gte: JSON
  lt: JSON
  lte: JSON
  not: JSON
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

input JsonWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedJsonFilter
  _min: NestedJsonFilter
  array_contains: JSON
  array_ends_with: JSON
  array_starts_with: JSON
  equals: JSON
  gt: JSON
  gte: JSON
  lt: JSON
  lte: JSON
  not: JSON
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

type Monitor {
  _count: MonitorCount
  collection: Collection!
  collectionId: Int!
  collectionRuns(cursor: CollectionRunWhereUniqueInput, distinct: [CollectionRunScalarFieldEnum!], orderBy: [CollectionRunOrderByWithRelationInput!], skip: Int, take: Int, where: CollectionRunWhereInput): [CollectionRun!]!
  createdAt: DateTime!
  env: String!
  id: Int!
  schedule: String!
}

type MonitorAvgAggregate {
  collectionId: Float
  id: Float
}

input MonitorAvgOrderByAggregateInput {
  collectionId: SortOrder
  id: SortOrder
}

type MonitorCount {
  collectionRuns: Int!
}

type MonitorCountAggregate {
  _all: Int!
  collectionId: Int!
  createdAt: Int!
  env: Int!
  id: Int!
  schedule: Int!
}

input MonitorCountOrderByAggregateInput {
  collectionId: SortOrder
  createdAt: SortOrder
  env: SortOrder
  id: SortOrder
  schedule: SortOrder
}

input MonitorCreateInput {
  collection: CollectionCreateNestedOneWithoutMonitorInput!
  collectionRuns: CollectionRunCreateNestedManyWithoutMonitorInput
  createdAt: DateTime
  env: String!
  schedule: String!
}

input MonitorCreateManyCollectionInput {
  createdAt: DateTime
  env: String!
  id: Int
  schedule: String!
}

input MonitorCreateManyCollectionInputEnvelope {
  data: [MonitorCreateManyCollectionInput!]!
  skipDuplicates: Boolean
}

input MonitorCreateManyInput {
  collectionId: Int!
  createdAt: DateTime
  env: String!
  id: Int
  schedule: String!
}

input MonitorCreateNestedManyWithoutCollectionInput {
  connect: [MonitorWhereUniqueInput!]
  connectOrCreate: [MonitorCreateOrConnectWithoutCollectionInput!]
  create: [MonitorCreateWithoutCollectionInput!]
  createMany: MonitorCreateManyCollectionInputEnvelope
}

input MonitorCreateNestedOneWithoutCollectionRunsInput {
  connect: MonitorWhereUniqueInput
  connectOrCreate: MonitorCreateOrConnectWithoutCollectionRunsInput
  create: MonitorCreateWithoutCollectionRunsInput
}

input MonitorCreateOrConnectWithoutCollectionInput {
  create: MonitorCreateWithoutCollectionInput!
  where: MonitorWhereUniqueInput!
}

input MonitorCreateOrConnectWithoutCollectionRunsInput {
  create: MonitorCreateWithoutCollectionRunsInput!
  where: MonitorWhereUniqueInput!
}

input MonitorCreateWithoutCollectionInput {
  collectionRuns: CollectionRunCreateNestedManyWithoutMonitorInput
  createdAt: DateTime
  env: String!
  schedule: String!
}

input MonitorCreateWithoutCollectionRunsInput {
  collection: CollectionCreateNestedOneWithoutMonitorInput!
  createdAt: DateTime
  env: String!
  schedule: String!
}

type MonitorGroupBy {
  _avg: MonitorAvgAggregate
  _count: MonitorCountAggregate
  _max: MonitorMaxAggregate
  _min: MonitorMinAggregate
  _sum: MonitorSumAggregate
  collectionId: Int!
  createdAt: DateTime!
  env: String!
  id: Int!
  schedule: String!
}

input MonitorListRelationFilter {
  every: MonitorWhereInput
  none: MonitorWhereInput
  some: MonitorWhereInput
}

type MonitorMaxAggregate {
  collectionId: Int
  createdAt: DateTime
  env: String
  id: Int
  schedule: String
}

input MonitorMaxOrderByAggregateInput {
  collectionId: SortOrder
  createdAt: SortOrder
  env: SortOrder
  id: SortOrder
  schedule: SortOrder
}

type MonitorMinAggregate {
  collectionId: Int
  createdAt: DateTime
  env: String
  id: Int
  schedule: String
}

input MonitorMinOrderByAggregateInput {
  collectionId: SortOrder
  createdAt: SortOrder
  env: SortOrder
  id: SortOrder
  schedule: SortOrder
}

input MonitorOrderByRelationAggregateInput {
  _count: SortOrder
}

input MonitorOrderByWithAggregationInput {
  _avg: MonitorAvgOrderByAggregateInput
  _count: MonitorCountOrderByAggregateInput
  _max: MonitorMaxOrderByAggregateInput
  _min: MonitorMinOrderByAggregateInput
  _sum: MonitorSumOrderByAggregateInput
  collectionId: SortOrder
  createdAt: SortOrder
  env: SortOrder
  id: SortOrder
  schedule: SortOrder
}

input MonitorOrderByWithRelationInput {
  collection: CollectionOrderByWithRelationInput
  collectionId: SortOrder
  collectionRuns: CollectionRunOrderByRelationAggregateInput
  createdAt: SortOrder
  env: SortOrder
  id: SortOrder
  schedule: SortOrder
}

input MonitorRelationFilter {
  is: MonitorWhereInput
  isNot: MonitorWhereInput
}

enum MonitorScalarFieldEnum {
  collectionId
  createdAt
  env
  id
  schedule
}

input MonitorScalarWhereInput {
  AND: [MonitorScalarWhereInput!]
  NOT: [MonitorScalarWhereInput!]
  OR: [MonitorScalarWhereInput!]
  collectionId: IntFilter
  createdAt: DateTimeFilter
  env: StringFilter
  id: IntFilter
  schedule: StringFilter
}

input MonitorScalarWhereWithAggregatesInput {
  AND: [MonitorScalarWhereWithAggregatesInput!]
  NOT: [MonitorScalarWhereWithAggregatesInput!]
  OR: [MonitorScalarWhereWithAggregatesInput!]
  collectionId: IntWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  env: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  schedule: StringWithAggregatesFilter
}

type MonitorSumAggregate {
  collectionId: Int
  id: Int
}

input MonitorSumOrderByAggregateInput {
  collectionId: SortOrder
  id: SortOrder
}

input MonitorUpdateInput {
  collection: CollectionUpdateOneRequiredWithoutMonitorNestedInput
  collectionRuns: CollectionRunUpdateManyWithoutMonitorNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  env: StringFieldUpdateOperationsInput
  schedule: StringFieldUpdateOperationsInput
}

input MonitorUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  env: StringFieldUpdateOperationsInput
  schedule: StringFieldUpdateOperationsInput
}

input MonitorUpdateManyWithWhereWithoutCollectionInput {
  data: MonitorUpdateManyMutationInput!
  where: MonitorScalarWhereInput!
}

input MonitorUpdateManyWithoutCollectionNestedInput {
  connect: [MonitorWhereUniqueInput!]
  connectOrCreate: [MonitorCreateOrConnectWithoutCollectionInput!]
  create: [MonitorCreateWithoutCollectionInput!]
  createMany: MonitorCreateManyCollectionInputEnvelope
  delete: [MonitorWhereUniqueInput!]
  deleteMany: [MonitorScalarWhereInput!]
  disconnect: [MonitorWhereUniqueInput!]
  set: [MonitorWhereUniqueInput!]
  update: [MonitorUpdateWithWhereUniqueWithoutCollectionInput!]
  updateMany: [MonitorUpdateManyWithWhereWithoutCollectionInput!]
  upsert: [MonitorUpsertWithWhereUniqueWithoutCollectionInput!]
}

input MonitorUpdateOneRequiredWithoutCollectionRunsNestedInput {
  connect: MonitorWhereUniqueInput
  connectOrCreate: MonitorCreateOrConnectWithoutCollectionRunsInput
  create: MonitorCreateWithoutCollectionRunsInput
  update: MonitorUpdateWithoutCollectionRunsInput
  upsert: MonitorUpsertWithoutCollectionRunsInput
}

input MonitorUpdateWithWhereUniqueWithoutCollectionInput {
  data: MonitorUpdateWithoutCollectionInput!
  where: MonitorWhereUniqueInput!
}

input MonitorUpdateWithoutCollectionInput {
  collectionRuns: CollectionRunUpdateManyWithoutMonitorNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  env: StringFieldUpdateOperationsInput
  schedule: StringFieldUpdateOperationsInput
}

input MonitorUpdateWithoutCollectionRunsInput {
  collection: CollectionUpdateOneRequiredWithoutMonitorNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  env: StringFieldUpdateOperationsInput
  schedule: StringFieldUpdateOperationsInput
}

input MonitorUpsertWithWhereUniqueWithoutCollectionInput {
  create: MonitorCreateWithoutCollectionInput!
  update: MonitorUpdateWithoutCollectionInput!
  where: MonitorWhereUniqueInput!
}

input MonitorUpsertWithoutCollectionRunsInput {
  create: MonitorCreateWithoutCollectionRunsInput!
  update: MonitorUpdateWithoutCollectionRunsInput!
}

input MonitorWhereInput {
  AND: [MonitorWhereInput!]
  NOT: [MonitorWhereInput!]
  OR: [MonitorWhereInput!]
  collection: CollectionRelationFilter
  collectionId: IntFilter
  collectionRuns: CollectionRunListRelationFilter
  createdAt: DateTimeFilter
  env: StringFilter
  id: IntFilter
  schedule: StringFilter
}

input MonitorWhereUniqueInput {
  id: Int
}

type Mutation {
  createManyAssertion(data: [AssertionCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyCollection(data: [CollectionCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyCollectionRun(data: [CollectionRunCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyMonitor(data: [MonitorCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyRequest(data: [RequestCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyResponse(data: [ResponseCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOneAssertion(data: AssertionCreateInput!): Assertion!
  createOneCollection(data: CollectionCreateInput!): Collection!
  createOneCollectionRun(data: CollectionRunCreateInput!): CollectionRun!
  createOneMonitor(data: MonitorCreateInput!): Monitor!
  createOneRequest(data: RequestCreateInput!): Request!
  createOneResponse(data: ResponseCreateInput!): Response!
  deleteManyAssertion(where: AssertionWhereInput): AffectedRowsOutput!
  deleteManyCollection(where: CollectionWhereInput): AffectedRowsOutput!
  deleteManyCollectionRun(where: CollectionRunWhereInput): AffectedRowsOutput!
  deleteManyMonitor(where: MonitorWhereInput): AffectedRowsOutput!
  deleteManyRequest(where: RequestWhereInput): AffectedRowsOutput!
  deleteManyResponse(where: ResponseWhereInput): AffectedRowsOutput!
  deleteOneAssertion(where: AssertionWhereUniqueInput!): Assertion
  deleteOneCollection(where: CollectionWhereUniqueInput!): Collection
  deleteOneCollectionRun(where: CollectionRunWhereUniqueInput!): CollectionRun
  deleteOneMonitor(where: MonitorWhereUniqueInput!): Monitor
  deleteOneRequest(where: RequestWhereUniqueInput!): Request
  deleteOneResponse(where: ResponseWhereUniqueInput!): Response
  updateManyAssertion(data: AssertionUpdateManyMutationInput!, where: AssertionWhereInput): AffectedRowsOutput!
  updateManyCollection(data: CollectionUpdateManyMutationInput!, where: CollectionWhereInput): AffectedRowsOutput!
  updateManyCollectionRun(data: CollectionRunUpdateManyMutationInput!, where: CollectionRunWhereInput): AffectedRowsOutput!
  updateManyMonitor(data: MonitorUpdateManyMutationInput!, where: MonitorWhereInput): AffectedRowsOutput!
  updateManyRequest(data: RequestUpdateManyMutationInput!, where: RequestWhereInput): AffectedRowsOutput!
  updateManyResponse(data: ResponseUpdateManyMutationInput!, where: ResponseWhereInput): AffectedRowsOutput!
  updateOneAssertion(data: AssertionUpdateInput!, where: AssertionWhereUniqueInput!): Assertion
  updateOneCollection(data: CollectionUpdateInput!, where: CollectionWhereUniqueInput!): Collection
  updateOneCollectionRun(data: CollectionRunUpdateInput!, where: CollectionRunWhereUniqueInput!): CollectionRun
  updateOneMonitor(data: MonitorUpdateInput!, where: MonitorWhereUniqueInput!): Monitor
  updateOneRequest(data: RequestUpdateInput!, where: RequestWhereUniqueInput!): Request
  updateOneResponse(data: ResponseUpdateInput!, where: ResponseWhereUniqueInput!): Response
  upsertOneAssertion(create: AssertionCreateInput!, update: AssertionUpdateInput!, where: AssertionWhereUniqueInput!): Assertion!
  upsertOneCollection(create: CollectionCreateInput!, update: CollectionUpdateInput!, where: CollectionWhereUniqueInput!): Collection!
  upsertOneCollectionRun(create: CollectionRunCreateInput!, update: CollectionRunUpdateInput!, where: CollectionRunWhereUniqueInput!): CollectionRun!
  upsertOneMonitor(create: MonitorCreateInput!, update: MonitorUpdateInput!, where: MonitorWhereUniqueInput!): Monitor!
  upsertOneRequest(create: RequestCreateInput!, update: RequestUpdateInput!, where: RequestWhereUniqueInput!): Request!
  upsertOneResponse(create: ResponseCreateInput!, update: ResponseUpdateInput!, where: ResponseWhereUniqueInput!): Response!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedJsonFilter {
  array_contains: JSON
  array_ends_with: JSON
  array_starts_with: JSON
  equals: JSON
  gt: JSON
  gte: JSON
  lt: JSON
  lte: JSON
  not: JSON
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Query {
  aggregateAssertion(cursor: AssertionWhereUniqueInput, orderBy: [AssertionOrderByWithRelationInput!], skip: Int, take: Int, where: AssertionWhereInput): AggregateAssertion!
  aggregateCollection(cursor: CollectionWhereUniqueInput, orderBy: [CollectionOrderByWithRelationInput!], skip: Int, take: Int, where: CollectionWhereInput): AggregateCollection!
  aggregateCollectionRun(cursor: CollectionRunWhereUniqueInput, orderBy: [CollectionRunOrderByWithRelationInput!], skip: Int, take: Int, where: CollectionRunWhereInput): AggregateCollectionRun!
  aggregateMonitor(cursor: MonitorWhereUniqueInput, orderBy: [MonitorOrderByWithRelationInput!], skip: Int, take: Int, where: MonitorWhereInput): AggregateMonitor!
  aggregateRequest(cursor: RequestWhereUniqueInput, orderBy: [RequestOrderByWithRelationInput!], skip: Int, take: Int, where: RequestWhereInput): AggregateRequest!
  aggregateResponse(cursor: ResponseWhereUniqueInput, orderBy: [ResponseOrderByWithRelationInput!], skip: Int, take: Int, where: ResponseWhereInput): AggregateResponse!
  assertion(where: AssertionWhereUniqueInput!): Assertion
  assertions(cursor: AssertionWhereUniqueInput, distinct: [AssertionScalarFieldEnum!], orderBy: [AssertionOrderByWithRelationInput!], skip: Int, take: Int, where: AssertionWhereInput): [Assertion!]!
  collection(where: CollectionWhereUniqueInput!): Collection
  collectionRun(where: CollectionRunWhereUniqueInput!): CollectionRun
  collectionRuns(cursor: CollectionRunWhereUniqueInput, distinct: [CollectionRunScalarFieldEnum!], orderBy: [CollectionRunOrderByWithRelationInput!], skip: Int, take: Int, where: CollectionRunWhereInput): [CollectionRun!]!
  collections(cursor: CollectionWhereUniqueInput, distinct: [CollectionScalarFieldEnum!], orderBy: [CollectionOrderByWithRelationInput!], skip: Int, take: Int, where: CollectionWhereInput): [Collection!]!
  findFirstAssertion(cursor: AssertionWhereUniqueInput, distinct: [AssertionScalarFieldEnum!], orderBy: [AssertionOrderByWithRelationInput!], skip: Int, take: Int, where: AssertionWhereInput): Assertion
  findFirstCollection(cursor: CollectionWhereUniqueInput, distinct: [CollectionScalarFieldEnum!], orderBy: [CollectionOrderByWithRelationInput!], skip: Int, take: Int, where: CollectionWhereInput): Collection
  findFirstCollectionRun(cursor: CollectionRunWhereUniqueInput, distinct: [CollectionRunScalarFieldEnum!], orderBy: [CollectionRunOrderByWithRelationInput!], skip: Int, take: Int, where: CollectionRunWhereInput): CollectionRun
  findFirstMonitor(cursor: MonitorWhereUniqueInput, distinct: [MonitorScalarFieldEnum!], orderBy: [MonitorOrderByWithRelationInput!], skip: Int, take: Int, where: MonitorWhereInput): Monitor
  findFirstRequest(cursor: RequestWhereUniqueInput, distinct: [RequestScalarFieldEnum!], orderBy: [RequestOrderByWithRelationInput!], skip: Int, take: Int, where: RequestWhereInput): Request
  findFirstResponse(cursor: ResponseWhereUniqueInput, distinct: [ResponseScalarFieldEnum!], orderBy: [ResponseOrderByWithRelationInput!], skip: Int, take: Int, where: ResponseWhereInput): Response
  groupByAssertion(by: [AssertionScalarFieldEnum!]!, having: AssertionScalarWhereWithAggregatesInput, orderBy: [AssertionOrderByWithAggregationInput!], skip: Int, take: Int, where: AssertionWhereInput): [AssertionGroupBy!]!
  groupByCollection(by: [CollectionScalarFieldEnum!]!, having: CollectionScalarWhereWithAggregatesInput, orderBy: [CollectionOrderByWithAggregationInput!], skip: Int, take: Int, where: CollectionWhereInput): [CollectionGroupBy!]!
  groupByCollectionRun(by: [CollectionRunScalarFieldEnum!]!, having: CollectionRunScalarWhereWithAggregatesInput, orderBy: [CollectionRunOrderByWithAggregationInput!], skip: Int, take: Int, where: CollectionRunWhereInput): [CollectionRunGroupBy!]!
  groupByMonitor(by: [MonitorScalarFieldEnum!]!, having: MonitorScalarWhereWithAggregatesInput, orderBy: [MonitorOrderByWithAggregationInput!], skip: Int, take: Int, where: MonitorWhereInput): [MonitorGroupBy!]!
  groupByRequest(by: [RequestScalarFieldEnum!]!, having: RequestScalarWhereWithAggregatesInput, orderBy: [RequestOrderByWithAggregationInput!], skip: Int, take: Int, where: RequestWhereInput): [RequestGroupBy!]!
  groupByResponse(by: [ResponseScalarFieldEnum!]!, having: ResponseScalarWhereWithAggregatesInput, orderBy: [ResponseOrderByWithAggregationInput!], skip: Int, take: Int, where: ResponseWhereInput): [ResponseGroupBy!]!
  monitor(where: MonitorWhereUniqueInput!): Monitor
  monitors(cursor: MonitorWhereUniqueInput, distinct: [MonitorScalarFieldEnum!], orderBy: [MonitorOrderByWithRelationInput!], skip: Int, take: Int, where: MonitorWhereInput): [Monitor!]!
  request(where: RequestWhereUniqueInput!): Request
  requests(cursor: RequestWhereUniqueInput, distinct: [RequestScalarFieldEnum!], orderBy: [RequestOrderByWithRelationInput!], skip: Int, take: Int, where: RequestWhereInput): [Request!]!
  response(where: ResponseWhereUniqueInput!): Response
  responses(cursor: ResponseWhereUniqueInput, distinct: [ResponseScalarFieldEnum!], orderBy: [ResponseOrderByWithRelationInput!], skip: Int, take: Int, where: ResponseWhereInput): [Response!]!
}

enum QueryMode {
  default
  insensitive
}

type Request {
  _count: RequestCount
  assertions(cursor: AssertionWhereUniqueInput, distinct: [AssertionScalarFieldEnum!], orderBy: [AssertionOrderByWithRelationInput!], skip: Int, take: Int, where: AssertionWhereInput): [Assertion!]!
  body: JSON!
  collection: Collection!
  collectionId: Int!
  createdAt: DateTime!
  headers: JSON!
  id: Int!
  method: String!
  responses(cursor: ResponseWhereUniqueInput, distinct: [ResponseScalarFieldEnum!], orderBy: [ResponseOrderByWithRelationInput!], skip: Int, take: Int, where: ResponseWhereInput): [Response!]!
  title: String!
  url: String!
}

type RequestAvgAggregate {
  collectionId: Float
  id: Float
}

input RequestAvgOrderByAggregateInput {
  collectionId: SortOrder
  id: SortOrder
}

type RequestCount {
  assertions: Int!
  responses: Int!
}

type RequestCountAggregate {
  _all: Int!
  body: Int!
  collectionId: Int!
  createdAt: Int!
  headers: Int!
  id: Int!
  method: Int!
  title: Int!
  url: Int!
}

input RequestCountOrderByAggregateInput {
  body: SortOrder
  collectionId: SortOrder
  createdAt: SortOrder
  headers: SortOrder
  id: SortOrder
  method: SortOrder
  title: SortOrder
  url: SortOrder
}

input RequestCreateInput {
  assertions: AssertionCreateNestedManyWithoutRequestInput
  body: JSON!
  collection: CollectionCreateNestedOneWithoutRequestsInput!
  createdAt: DateTime
  headers: JSON!
  method: String!
  responses: ResponseCreateNestedManyWithoutRequestInput
  title: String!
  url: String!
}

input RequestCreateManyCollectionInput {
  body: JSON!
  createdAt: DateTime
  headers: JSON!
  id: Int
  method: String!
  title: String!
  url: String!
}

input RequestCreateManyCollectionInputEnvelope {
  data: [RequestCreateManyCollectionInput!]!
  skipDuplicates: Boolean
}

input RequestCreateManyInput {
  body: JSON!
  collectionId: Int!
  createdAt: DateTime
  headers: JSON!
  id: Int
  method: String!
  title: String!
  url: String!
}

input RequestCreateNestedManyWithoutCollectionInput {
  connect: [RequestWhereUniqueInput!]
  connectOrCreate: [RequestCreateOrConnectWithoutCollectionInput!]
  create: [RequestCreateWithoutCollectionInput!]
  createMany: RequestCreateManyCollectionInputEnvelope
}

input RequestCreateNestedOneWithoutAssertionsInput {
  connect: RequestWhereUniqueInput
  connectOrCreate: RequestCreateOrConnectWithoutAssertionsInput
  create: RequestCreateWithoutAssertionsInput
}

input RequestCreateNestedOneWithoutResponsesInput {
  connect: RequestWhereUniqueInput
  connectOrCreate: RequestCreateOrConnectWithoutResponsesInput
  create: RequestCreateWithoutResponsesInput
}

input RequestCreateOrConnectWithoutAssertionsInput {
  create: RequestCreateWithoutAssertionsInput!
  where: RequestWhereUniqueInput!
}

input RequestCreateOrConnectWithoutCollectionInput {
  create: RequestCreateWithoutCollectionInput!
  where: RequestWhereUniqueInput!
}

input RequestCreateOrConnectWithoutResponsesInput {
  create: RequestCreateWithoutResponsesInput!
  where: RequestWhereUniqueInput!
}

input RequestCreateWithoutAssertionsInput {
  body: JSON!
  collection: CollectionCreateNestedOneWithoutRequestsInput!
  createdAt: DateTime
  headers: JSON!
  method: String!
  responses: ResponseCreateNestedManyWithoutRequestInput
  title: String!
  url: String!
}

input RequestCreateWithoutCollectionInput {
  assertions: AssertionCreateNestedManyWithoutRequestInput
  body: JSON!
  createdAt: DateTime
  headers: JSON!
  method: String!
  responses: ResponseCreateNestedManyWithoutRequestInput
  title: String!
  url: String!
}

input RequestCreateWithoutResponsesInput {
  assertions: AssertionCreateNestedManyWithoutRequestInput
  body: JSON!
  collection: CollectionCreateNestedOneWithoutRequestsInput!
  createdAt: DateTime
  headers: JSON!
  method: String!
  title: String!
  url: String!
}

type RequestGroupBy {
  _avg: RequestAvgAggregate
  _count: RequestCountAggregate
  _max: RequestMaxAggregate
  _min: RequestMinAggregate
  _sum: RequestSumAggregate
  body: JSON!
  collectionId: Int!
  createdAt: DateTime!
  headers: JSON!
  id: Int!
  method: String!
  title: String!
  url: String!
}

input RequestListRelationFilter {
  every: RequestWhereInput
  none: RequestWhereInput
  some: RequestWhereInput
}

type RequestMaxAggregate {
  collectionId: Int
  createdAt: DateTime
  id: Int
  method: String
  title: String
  url: String
}

input RequestMaxOrderByAggregateInput {
  collectionId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  method: SortOrder
  title: SortOrder
  url: SortOrder
}

type RequestMinAggregate {
  collectionId: Int
  createdAt: DateTime
  id: Int
  method: String
  title: String
  url: String
}

input RequestMinOrderByAggregateInput {
  collectionId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  method: SortOrder
  title: SortOrder
  url: SortOrder
}

input RequestOrderByRelationAggregateInput {
  _count: SortOrder
}

input RequestOrderByWithAggregationInput {
  _avg: RequestAvgOrderByAggregateInput
  _count: RequestCountOrderByAggregateInput
  _max: RequestMaxOrderByAggregateInput
  _min: RequestMinOrderByAggregateInput
  _sum: RequestSumOrderByAggregateInput
  body: SortOrder
  collectionId: SortOrder
  createdAt: SortOrder
  headers: SortOrder
  id: SortOrder
  method: SortOrder
  title: SortOrder
  url: SortOrder
}

input RequestOrderByWithRelationInput {
  assertions: AssertionOrderByRelationAggregateInput
  body: SortOrder
  collection: CollectionOrderByWithRelationInput
  collectionId: SortOrder
  createdAt: SortOrder
  headers: SortOrder
  id: SortOrder
  method: SortOrder
  responses: ResponseOrderByRelationAggregateInput
  title: SortOrder
  url: SortOrder
}

input RequestRelationFilter {
  is: RequestWhereInput
  isNot: RequestWhereInput
}

enum RequestScalarFieldEnum {
  body
  collectionId
  createdAt
  headers
  id
  method
  title
  url
}

input RequestScalarWhereInput {
  AND: [RequestScalarWhereInput!]
  NOT: [RequestScalarWhereInput!]
  OR: [RequestScalarWhereInput!]
  body: JsonFilter
  collectionId: IntFilter
  createdAt: DateTimeFilter
  headers: JsonFilter
  id: IntFilter
  method: StringFilter
  title: StringFilter
  url: StringFilter
}

input RequestScalarWhereWithAggregatesInput {
  AND: [RequestScalarWhereWithAggregatesInput!]
  NOT: [RequestScalarWhereWithAggregatesInput!]
  OR: [RequestScalarWhereWithAggregatesInput!]
  body: JsonWithAggregatesFilter
  collectionId: IntWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  headers: JsonWithAggregatesFilter
  id: IntWithAggregatesFilter
  method: StringWithAggregatesFilter
  title: StringWithAggregatesFilter
  url: StringWithAggregatesFilter
}

type RequestSumAggregate {
  collectionId: Int
  id: Int
}

input RequestSumOrderByAggregateInput {
  collectionId: SortOrder
  id: SortOrder
}

input RequestUpdateInput {
  assertions: AssertionUpdateManyWithoutRequestNestedInput
  body: JSON
  collection: CollectionUpdateOneRequiredWithoutRequestsNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  headers: JSON
  method: StringFieldUpdateOperationsInput
  responses: ResponseUpdateManyWithoutRequestNestedInput
  title: StringFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
}

input RequestUpdateManyMutationInput {
  body: JSON
  createdAt: DateTimeFieldUpdateOperationsInput
  headers: JSON
  method: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
}

input RequestUpdateManyWithWhereWithoutCollectionInput {
  data: RequestUpdateManyMutationInput!
  where: RequestScalarWhereInput!
}

input RequestUpdateManyWithoutCollectionNestedInput {
  connect: [RequestWhereUniqueInput!]
  connectOrCreate: [RequestCreateOrConnectWithoutCollectionInput!]
  create: [RequestCreateWithoutCollectionInput!]
  createMany: RequestCreateManyCollectionInputEnvelope
  delete: [RequestWhereUniqueInput!]
  deleteMany: [RequestScalarWhereInput!]
  disconnect: [RequestWhereUniqueInput!]
  set: [RequestWhereUniqueInput!]
  update: [RequestUpdateWithWhereUniqueWithoutCollectionInput!]
  updateMany: [RequestUpdateManyWithWhereWithoutCollectionInput!]
  upsert: [RequestUpsertWithWhereUniqueWithoutCollectionInput!]
}

input RequestUpdateOneRequiredWithoutAssertionsNestedInput {
  connect: RequestWhereUniqueInput
  connectOrCreate: RequestCreateOrConnectWithoutAssertionsInput
  create: RequestCreateWithoutAssertionsInput
  update: RequestUpdateWithoutAssertionsInput
  upsert: RequestUpsertWithoutAssertionsInput
}

input RequestUpdateOneRequiredWithoutResponsesNestedInput {
  connect: RequestWhereUniqueInput
  connectOrCreate: RequestCreateOrConnectWithoutResponsesInput
  create: RequestCreateWithoutResponsesInput
  update: RequestUpdateWithoutResponsesInput
  upsert: RequestUpsertWithoutResponsesInput
}

input RequestUpdateWithWhereUniqueWithoutCollectionInput {
  data: RequestUpdateWithoutCollectionInput!
  where: RequestWhereUniqueInput!
}

input RequestUpdateWithoutAssertionsInput {
  body: JSON
  collection: CollectionUpdateOneRequiredWithoutRequestsNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  headers: JSON
  method: StringFieldUpdateOperationsInput
  responses: ResponseUpdateManyWithoutRequestNestedInput
  title: StringFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
}

input RequestUpdateWithoutCollectionInput {
  assertions: AssertionUpdateManyWithoutRequestNestedInput
  body: JSON
  createdAt: DateTimeFieldUpdateOperationsInput
  headers: JSON
  method: StringFieldUpdateOperationsInput
  responses: ResponseUpdateManyWithoutRequestNestedInput
  title: StringFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
}

input RequestUpdateWithoutResponsesInput {
  assertions: AssertionUpdateManyWithoutRequestNestedInput
  body: JSON
  collection: CollectionUpdateOneRequiredWithoutRequestsNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  headers: JSON
  method: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
}

input RequestUpsertWithWhereUniqueWithoutCollectionInput {
  create: RequestCreateWithoutCollectionInput!
  update: RequestUpdateWithoutCollectionInput!
  where: RequestWhereUniqueInput!
}

input RequestUpsertWithoutAssertionsInput {
  create: RequestCreateWithoutAssertionsInput!
  update: RequestUpdateWithoutAssertionsInput!
}

input RequestUpsertWithoutResponsesInput {
  create: RequestCreateWithoutResponsesInput!
  update: RequestUpdateWithoutResponsesInput!
}

input RequestWhereInput {
  AND: [RequestWhereInput!]
  NOT: [RequestWhereInput!]
  OR: [RequestWhereInput!]
  assertions: AssertionListRelationFilter
  body: JsonFilter
  collection: CollectionRelationFilter
  collectionId: IntFilter
  createdAt: DateTimeFilter
  headers: JsonFilter
  id: IntFilter
  method: StringFilter
  responses: ResponseListRelationFilter
  title: StringFilter
  url: StringFilter
}

input RequestWhereUniqueInput {
  id: Int
}

type Response {
  createdAt: DateTime!
  headers: JSON!
  id: Int!
  latency: Int!
  request: Request!
  requestId: Int!
  status: Int!
}

type ResponseAvgAggregate {
  id: Float
  latency: Float
  requestId: Float
  status: Float
}

input ResponseAvgOrderByAggregateInput {
  id: SortOrder
  latency: SortOrder
  requestId: SortOrder
  status: SortOrder
}

type ResponseCountAggregate {
  _all: Int!
  createdAt: Int!
  headers: Int!
  id: Int!
  latency: Int!
  requestId: Int!
  status: Int!
}

input ResponseCountOrderByAggregateInput {
  createdAt: SortOrder
  headers: SortOrder
  id: SortOrder
  latency: SortOrder
  requestId: SortOrder
  status: SortOrder
}

input ResponseCreateInput {
  createdAt: DateTime
  headers: JSON!
  latency: Int!
  request: RequestCreateNestedOneWithoutResponsesInput!
  status: Int!
}

input ResponseCreateManyInput {
  createdAt: DateTime
  headers: JSON!
  id: Int
  latency: Int!
  requestId: Int!
  status: Int!
}

input ResponseCreateManyRequestInput {
  createdAt: DateTime
  headers: JSON!
  id: Int
  latency: Int!
  status: Int!
}

input ResponseCreateManyRequestInputEnvelope {
  data: [ResponseCreateManyRequestInput!]!
  skipDuplicates: Boolean
}

input ResponseCreateNestedManyWithoutRequestInput {
  connect: [ResponseWhereUniqueInput!]
  connectOrCreate: [ResponseCreateOrConnectWithoutRequestInput!]
  create: [ResponseCreateWithoutRequestInput!]
  createMany: ResponseCreateManyRequestInputEnvelope
}

input ResponseCreateOrConnectWithoutRequestInput {
  create: ResponseCreateWithoutRequestInput!
  where: ResponseWhereUniqueInput!
}

input ResponseCreateWithoutRequestInput {
  createdAt: DateTime
  headers: JSON!
  latency: Int!
  status: Int!
}

type ResponseGroupBy {
  _avg: ResponseAvgAggregate
  _count: ResponseCountAggregate
  _max: ResponseMaxAggregate
  _min: ResponseMinAggregate
  _sum: ResponseSumAggregate
  createdAt: DateTime!
  headers: JSON!
  id: Int!
  latency: Int!
  requestId: Int!
  status: Int!
}

input ResponseListRelationFilter {
  every: ResponseWhereInput
  none: ResponseWhereInput
  some: ResponseWhereInput
}

type ResponseMaxAggregate {
  createdAt: DateTime
  id: Int
  latency: Int
  requestId: Int
  status: Int
}

input ResponseMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  latency: SortOrder
  requestId: SortOrder
  status: SortOrder
}

type ResponseMinAggregate {
  createdAt: DateTime
  id: Int
  latency: Int
  requestId: Int
  status: Int
}

input ResponseMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  latency: SortOrder
  requestId: SortOrder
  status: SortOrder
}

input ResponseOrderByRelationAggregateInput {
  _count: SortOrder
}

input ResponseOrderByWithAggregationInput {
  _avg: ResponseAvgOrderByAggregateInput
  _count: ResponseCountOrderByAggregateInput
  _max: ResponseMaxOrderByAggregateInput
  _min: ResponseMinOrderByAggregateInput
  _sum: ResponseSumOrderByAggregateInput
  createdAt: SortOrder
  headers: SortOrder
  id: SortOrder
  latency: SortOrder
  requestId: SortOrder
  status: SortOrder
}

input ResponseOrderByWithRelationInput {
  createdAt: SortOrder
  headers: SortOrder
  id: SortOrder
  latency: SortOrder
  request: RequestOrderByWithRelationInput
  requestId: SortOrder
  status: SortOrder
}

enum ResponseScalarFieldEnum {
  createdAt
  headers
  id
  latency
  requestId
  status
}

input ResponseScalarWhereInput {
  AND: [ResponseScalarWhereInput!]
  NOT: [ResponseScalarWhereInput!]
  OR: [ResponseScalarWhereInput!]
  createdAt: DateTimeFilter
  headers: JsonFilter
  id: IntFilter
  latency: IntFilter
  requestId: IntFilter
  status: IntFilter
}

input ResponseScalarWhereWithAggregatesInput {
  AND: [ResponseScalarWhereWithAggregatesInput!]
  NOT: [ResponseScalarWhereWithAggregatesInput!]
  OR: [ResponseScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  headers: JsonWithAggregatesFilter
  id: IntWithAggregatesFilter
  latency: IntWithAggregatesFilter
  requestId: IntWithAggregatesFilter
  status: IntWithAggregatesFilter
}

type ResponseSumAggregate {
  id: Int
  latency: Int
  requestId: Int
  status: Int
}

input ResponseSumOrderByAggregateInput {
  id: SortOrder
  latency: SortOrder
  requestId: SortOrder
  status: SortOrder
}

input ResponseUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  headers: JSON
  latency: IntFieldUpdateOperationsInput
  request: RequestUpdateOneRequiredWithoutResponsesNestedInput
  status: IntFieldUpdateOperationsInput
}

input ResponseUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  headers: JSON
  latency: IntFieldUpdateOperationsInput
  status: IntFieldUpdateOperationsInput
}

input ResponseUpdateManyWithWhereWithoutRequestInput {
  data: ResponseUpdateManyMutationInput!
  where: ResponseScalarWhereInput!
}

input ResponseUpdateManyWithoutRequestNestedInput {
  connect: [ResponseWhereUniqueInput!]
  connectOrCreate: [ResponseCreateOrConnectWithoutRequestInput!]
  create: [ResponseCreateWithoutRequestInput!]
  createMany: ResponseCreateManyRequestInputEnvelope
  delete: [ResponseWhereUniqueInput!]
  deleteMany: [ResponseScalarWhereInput!]
  disconnect: [ResponseWhereUniqueInput!]
  set: [ResponseWhereUniqueInput!]
  update: [ResponseUpdateWithWhereUniqueWithoutRequestInput!]
  updateMany: [ResponseUpdateManyWithWhereWithoutRequestInput!]
  upsert: [ResponseUpsertWithWhereUniqueWithoutRequestInput!]
}

input ResponseUpdateWithWhereUniqueWithoutRequestInput {
  data: ResponseUpdateWithoutRequestInput!
  where: ResponseWhereUniqueInput!
}

input ResponseUpdateWithoutRequestInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  headers: JSON
  latency: IntFieldUpdateOperationsInput
  status: IntFieldUpdateOperationsInput
}

input ResponseUpsertWithWhereUniqueWithoutRequestInput {
  create: ResponseCreateWithoutRequestInput!
  update: ResponseUpdateWithoutRequestInput!
  where: ResponseWhereUniqueInput!
}

input ResponseWhereInput {
  AND: [ResponseWhereInput!]
  NOT: [ResponseWhereInput!]
  OR: [ResponseWhereInput!]
  createdAt: DateTimeFilter
  headers: JsonFilter
  id: IntFilter
  latency: IntFilter
  request: RequestRelationFilter
  requestId: IntFilter
  status: IntFilter
}

input ResponseWhereUniqueInput {
  id: Int
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}
