# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateAssertion {
  _avg: AssertionAvgAggregate
  _count: AssertionCountAggregate
  _max: AssertionMaxAggregate
  _min: AssertionMinAggregate
  _sum: AssertionSumAggregate
}

type AggregateAssertionResults {
  _avg: AssertionResultsAvgAggregate
  _count: AssertionResultsCountAggregate
  _max: AssertionResultsMaxAggregate
  _min: AssertionResultsMinAggregate
  _sum: AssertionResultsSumAggregate
}

type AggregateCollection {
  _avg: CollectionAvgAggregate
  _count: CollectionCountAggregate
  _max: CollectionMaxAggregate
  _min: CollectionMinAggregate
  _sum: CollectionSumAggregate
}

type AggregateCollectionRun {
  _avg: CollectionRunAvgAggregate
  _count: CollectionRunCountAggregate
  _max: CollectionRunMaxAggregate
  _min: CollectionRunMinAggregate
  _sum: CollectionRunSumAggregate
}

type AggregateMonitor {
  _avg: MonitorAvgAggregate
  _count: MonitorCountAggregate
  _max: MonitorMaxAggregate
  _min: MonitorMinAggregate
  _sum: MonitorSumAggregate
}

type AggregateRequest {
  _avg: RequestAvgAggregate
  _count: RequestCountAggregate
  _max: RequestMaxAggregate
  _min: RequestMinAggregate
  _sum: RequestSumAggregate
}

type AggregateResponse {
  _avg: ResponseAvgAggregate
  _count: ResponseCountAggregate
  _max: ResponseMaxAggregate
  _min: ResponseMinAggregate
  _sum: ResponseSumAggregate
}

type Assertion {
  AssertionResults(cursor: AssertionResultsWhereUniqueInput, distinct: [AssertionResultsScalarFieldEnum!], orderBy: [AssertionResultsOrderByWithRelationInput!], skip: Int, take: Int, where: AssertionResultsWhereInput): [AssertionResults!]!
  _count: AssertionCount
  comparison: String!
  createdAt: DateTime!
  expected: String!
  id: Int!
  property: String!
  request: Request!
  requestId: Int!
}

type AssertionAvgAggregate {
  id: Float
  requestId: Float
}

input AssertionAvgOrderByAggregateInput {
  id: SortOrder
  requestId: SortOrder
}

type AssertionCount {
  AssertionResults: Int!
}

type AssertionCountAggregate {
  _all: Int!
  comparison: Int!
  createdAt: Int!
  expected: Int!
  id: Int!
  property: Int!
  requestId: Int!
}

input AssertionCountOrderByAggregateInput {
  comparison: SortOrder
  createdAt: SortOrder
  expected: SortOrder
  id: SortOrder
  property: SortOrder
  requestId: SortOrder
}

input AssertionCreateInput {
  AssertionResults: AssertionResultsCreateNestedManyWithoutAssertionInput
  comparison: String!
  createdAt: DateTime
  expected: String!
  property: String!
  request: RequestCreateNestedOneWithoutAssertionsInput!
}

input AssertionCreateManyInput {
  comparison: String!
  createdAt: DateTime
  expected: String!
  id: Int
  property: String!
  requestId: Int!
}

input AssertionCreateManyRequestInput {
  comparison: String!
  createdAt: DateTime
  expected: String!
  id: Int
  property: String!
}

input AssertionCreateManyRequestInputEnvelope {
  data: [AssertionCreateManyRequestInput!]!
  skipDuplicates: Boolean
}

input AssertionCreateNestedManyWithoutRequestInput {
  connect: [AssertionWhereUniqueInput!]
  connectOrCreate: [AssertionCreateOrConnectWithoutRequestInput!]
  create: [AssertionCreateWithoutRequestInput!]
  createMany: AssertionCreateManyRequestInputEnvelope
}

input AssertionCreateNestedOneWithoutAssertionResultsInput {
  connect: AssertionWhereUniqueInput
  connectOrCreate: AssertionCreateOrConnectWithoutAssertionResultsInput
  create: AssertionCreateWithoutAssertionResultsInput
}

input AssertionCreateOrConnectWithoutAssertionResultsInput {
  create: AssertionCreateWithoutAssertionResultsInput!
  where: AssertionWhereUniqueInput!
}

input AssertionCreateOrConnectWithoutRequestInput {
  create: AssertionCreateWithoutRequestInput!
  where: AssertionWhereUniqueInput!
}

input AssertionCreateWithoutAssertionResultsInput {
  comparison: String!
  createdAt: DateTime
  expected: String!
  property: String!
  request: RequestCreateNestedOneWithoutAssertionsInput!
}

input AssertionCreateWithoutRequestInput {
  AssertionResults: AssertionResultsCreateNestedManyWithoutAssertionInput
  comparison: String!
  createdAt: DateTime
  expected: String!
  property: String!
}

type AssertionGroupBy {
  _avg: AssertionAvgAggregate
  _count: AssertionCountAggregate
  _max: AssertionMaxAggregate
  _min: AssertionMinAggregate
  _sum: AssertionSumAggregate
  comparison: String!
  createdAt: DateTime!
  expected: String!
  id: Int!
  property: String!
  requestId: Int!
}

input AssertionListRelationFilter {
  every: AssertionWhereInput
  none: AssertionWhereInput
  some: AssertionWhereInput
}

type AssertionMaxAggregate {
  comparison: String
  createdAt: DateTime
  expected: String
  id: Int
  property: String
  requestId: Int
}

input AssertionMaxOrderByAggregateInput {
  comparison: SortOrder
  createdAt: SortOrder
  expected: SortOrder
  id: SortOrder
  property: SortOrder
  requestId: SortOrder
}

type AssertionMinAggregate {
  comparison: String
  createdAt: DateTime
  expected: String
  id: Int
  property: String
  requestId: Int
}

input AssertionMinOrderByAggregateInput {
  comparison: SortOrder
  createdAt: SortOrder
  expected: SortOrder
  id: SortOrder
  property: SortOrder
  requestId: SortOrder
}

input AssertionOrderByRelationAggregateInput {
  _count: SortOrder
}

input AssertionOrderByWithAggregationInput {
  _avg: AssertionAvgOrderByAggregateInput
  _count: AssertionCountOrderByAggregateInput
  _max: AssertionMaxOrderByAggregateInput
  _min: AssertionMinOrderByAggregateInput
  _sum: AssertionSumOrderByAggregateInput
  comparison: SortOrder
  createdAt: SortOrder
  expected: SortOrder
  id: SortOrder
  property: SortOrder
  requestId: SortOrder
}

input AssertionOrderByWithRelationInput {
  AssertionResults: AssertionResultsOrderByRelationAggregateInput
  comparison: SortOrder
  createdAt: SortOrder
  expected: SortOrder
  id: SortOrder
  property: SortOrder
  request: RequestOrderByWithRelationInput
  requestId: SortOrder
}

input AssertionRelationFilter {
  is: AssertionWhereInput
  isNot: AssertionWhereInput
}

type AssertionResults {
  assertion: Assertion!
  assertionId: Int!
  createdAt: DateTime!
  id: Int!
  pass: Boolean!
  response: Response!
  responseId: Int!
}

type AssertionResultsAvgAggregate {
  assertionId: Float
  id: Float
  responseId: Float
}

input AssertionResultsAvgOrderByAggregateInput {
  assertionId: SortOrder
  id: SortOrder
  responseId: SortOrder
}

type AssertionResultsCountAggregate {
  _all: Int!
  assertionId: Int!
  createdAt: Int!
  id: Int!
  pass: Int!
  responseId: Int!
}

input AssertionResultsCountOrderByAggregateInput {
  assertionId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  pass: SortOrder
  responseId: SortOrder
}

input AssertionResultsCreateInput {
  assertion: AssertionCreateNestedOneWithoutAssertionResultsInput!
  createdAt: DateTime
  pass: Boolean!
  response: ResponseCreateNestedOneWithoutAssertionResultsInput!
}

input AssertionResultsCreateManyAssertionInput {
  createdAt: DateTime
  id: Int
  pass: Boolean!
  responseId: Int!
}

input AssertionResultsCreateManyAssertionInputEnvelope {
  data: [AssertionResultsCreateManyAssertionInput!]!
  skipDuplicates: Boolean
}

input AssertionResultsCreateManyInput {
  assertionId: Int!
  createdAt: DateTime
  id: Int
  pass: Boolean!
  responseId: Int!
}

input AssertionResultsCreateManyResponseInput {
  assertionId: Int!
  createdAt: DateTime
  id: Int
  pass: Boolean!
}

input AssertionResultsCreateManyResponseInputEnvelope {
  data: [AssertionResultsCreateManyResponseInput!]!
  skipDuplicates: Boolean
}

input AssertionResultsCreateNestedManyWithoutAssertionInput {
  connect: [AssertionResultsWhereUniqueInput!]
  connectOrCreate: [AssertionResultsCreateOrConnectWithoutAssertionInput!]
  create: [AssertionResultsCreateWithoutAssertionInput!]
  createMany: AssertionResultsCreateManyAssertionInputEnvelope
}

input AssertionResultsCreateNestedManyWithoutResponseInput {
  connect: [AssertionResultsWhereUniqueInput!]
  connectOrCreate: [AssertionResultsCreateOrConnectWithoutResponseInput!]
  create: [AssertionResultsCreateWithoutResponseInput!]
  createMany: AssertionResultsCreateManyResponseInputEnvelope
}

input AssertionResultsCreateOrConnectWithoutAssertionInput {
  create: AssertionResultsCreateWithoutAssertionInput!
  where: AssertionResultsWhereUniqueInput!
}

input AssertionResultsCreateOrConnectWithoutResponseInput {
  create: AssertionResultsCreateWithoutResponseInput!
  where: AssertionResultsWhereUniqueInput!
}

input AssertionResultsCreateWithoutAssertionInput {
  createdAt: DateTime
  pass: Boolean!
  response: ResponseCreateNestedOneWithoutAssertionResultsInput!
}

input AssertionResultsCreateWithoutResponseInput {
  assertion: AssertionCreateNestedOneWithoutAssertionResultsInput!
  createdAt: DateTime
  pass: Boolean!
}

type AssertionResultsGroupBy {
  _avg: AssertionResultsAvgAggregate
  _count: AssertionResultsCountAggregate
  _max: AssertionResultsMaxAggregate
  _min: AssertionResultsMinAggregate
  _sum: AssertionResultsSumAggregate
  assertionId: Int!
  createdAt: DateTime!
  id: Int!
  pass: Boolean!
  responseId: Int!
}

input AssertionResultsListRelationFilter {
  every: AssertionResultsWhereInput
  none: AssertionResultsWhereInput
  some: AssertionResultsWhereInput
}

type AssertionResultsMaxAggregate {
  assertionId: Int
  createdAt: DateTime
  id: Int
  pass: Boolean
  responseId: Int
}

input AssertionResultsMaxOrderByAggregateInput {
  assertionId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  pass: SortOrder
  responseId: SortOrder
}

type AssertionResultsMinAggregate {
  assertionId: Int
  createdAt: DateTime
  id: Int
  pass: Boolean
  responseId: Int
}

input AssertionResultsMinOrderByAggregateInput {
  assertionId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  pass: SortOrder
  responseId: SortOrder
}

input AssertionResultsOrderByRelationAggregateInput {
  _count: SortOrder
}

input AssertionResultsOrderByWithAggregationInput {
  _avg: AssertionResultsAvgOrderByAggregateInput
  _count: AssertionResultsCountOrderByAggregateInput
  _max: AssertionResultsMaxOrderByAggregateInput
  _min: AssertionResultsMinOrderByAggregateInput
  _sum: AssertionResultsSumOrderByAggregateInput
  assertionId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  pass: SortOrder
  responseId: SortOrder
}

input AssertionResultsOrderByWithRelationInput {
  assertion: AssertionOrderByWithRelationInput
  assertionId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  pass: SortOrder
  response: ResponseOrderByWithRelationInput
  responseId: SortOrder
}

enum AssertionResultsScalarFieldEnum {
  assertionId
  createdAt
  id
  pass
  responseId
}

input AssertionResultsScalarWhereInput {
  AND: [AssertionResultsScalarWhereInput!]
  NOT: [AssertionResultsScalarWhereInput!]
  OR: [AssertionResultsScalarWhereInput!]
  assertionId: IntFilter
  createdAt: DateTimeFilter
  id: IntFilter
  pass: BoolFilter
  responseId: IntFilter
}

input AssertionResultsScalarWhereWithAggregatesInput {
  AND: [AssertionResultsScalarWhereWithAggregatesInput!]
  NOT: [AssertionResultsScalarWhereWithAggregatesInput!]
  OR: [AssertionResultsScalarWhereWithAggregatesInput!]
  assertionId: IntWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  pass: BoolWithAggregatesFilter
  responseId: IntWithAggregatesFilter
}

type AssertionResultsSumAggregate {
  assertionId: Int
  id: Int
  responseId: Int
}

input AssertionResultsSumOrderByAggregateInput {
  assertionId: SortOrder
  id: SortOrder
  responseId: SortOrder
}

input AssertionResultsUpdateInput {
  assertion: AssertionUpdateOneRequiredWithoutAssertionResultsNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  pass: BoolFieldUpdateOperationsInput
  response: ResponseUpdateOneRequiredWithoutAssertionResultsNestedInput
}

input AssertionResultsUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  pass: BoolFieldUpdateOperationsInput
}

input AssertionResultsUpdateManyWithWhereWithoutAssertionInput {
  data: AssertionResultsUpdateManyMutationInput!
  where: AssertionResultsScalarWhereInput!
}

input AssertionResultsUpdateManyWithWhereWithoutResponseInput {
  data: AssertionResultsUpdateManyMutationInput!
  where: AssertionResultsScalarWhereInput!
}

input AssertionResultsUpdateManyWithoutAssertionNestedInput {
  connect: [AssertionResultsWhereUniqueInput!]
  connectOrCreate: [AssertionResultsCreateOrConnectWithoutAssertionInput!]
  create: [AssertionResultsCreateWithoutAssertionInput!]
  createMany: AssertionResultsCreateManyAssertionInputEnvelope
  delete: [AssertionResultsWhereUniqueInput!]
  deleteMany: [AssertionResultsScalarWhereInput!]
  disconnect: [AssertionResultsWhereUniqueInput!]
  set: [AssertionResultsWhereUniqueInput!]
  update: [AssertionResultsUpdateWithWhereUniqueWithoutAssertionInput!]
  updateMany: [AssertionResultsUpdateManyWithWhereWithoutAssertionInput!]
  upsert: [AssertionResultsUpsertWithWhereUniqueWithoutAssertionInput!]
}

input AssertionResultsUpdateManyWithoutResponseNestedInput {
  connect: [AssertionResultsWhereUniqueInput!]
  connectOrCreate: [AssertionResultsCreateOrConnectWithoutResponseInput!]
  create: [AssertionResultsCreateWithoutResponseInput!]
  createMany: AssertionResultsCreateManyResponseInputEnvelope
  delete: [AssertionResultsWhereUniqueInput!]
  deleteMany: [AssertionResultsScalarWhereInput!]
  disconnect: [AssertionResultsWhereUniqueInput!]
  set: [AssertionResultsWhereUniqueInput!]
  update: [AssertionResultsUpdateWithWhereUniqueWithoutResponseInput!]
  updateMany: [AssertionResultsUpdateManyWithWhereWithoutResponseInput!]
  upsert: [AssertionResultsUpsertWithWhereUniqueWithoutResponseInput!]
}

input AssertionResultsUpdateWithWhereUniqueWithoutAssertionInput {
  data: AssertionResultsUpdateWithoutAssertionInput!
  where: AssertionResultsWhereUniqueInput!
}

input AssertionResultsUpdateWithWhereUniqueWithoutResponseInput {
  data: AssertionResultsUpdateWithoutResponseInput!
  where: AssertionResultsWhereUniqueInput!
}

input AssertionResultsUpdateWithoutAssertionInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  pass: BoolFieldUpdateOperationsInput
  response: ResponseUpdateOneRequiredWithoutAssertionResultsNestedInput
}

input AssertionResultsUpdateWithoutResponseInput {
  assertion: AssertionUpdateOneRequiredWithoutAssertionResultsNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  pass: BoolFieldUpdateOperationsInput
}

input AssertionResultsUpsertWithWhereUniqueWithoutAssertionInput {
  create: AssertionResultsCreateWithoutAssertionInput!
  update: AssertionResultsUpdateWithoutAssertionInput!
  where: AssertionResultsWhereUniqueInput!
}

input AssertionResultsUpsertWithWhereUniqueWithoutResponseInput {
  create: AssertionResultsCreateWithoutResponseInput!
  update: AssertionResultsUpdateWithoutResponseInput!
  where: AssertionResultsWhereUniqueInput!
}

input AssertionResultsWhereInput {
  AND: [AssertionResultsWhereInput!]
  NOT: [AssertionResultsWhereInput!]
  OR: [AssertionResultsWhereInput!]
  assertion: AssertionRelationFilter
  assertionId: IntFilter
  createdAt: DateTimeFilter
  id: IntFilter
  pass: BoolFilter
  response: ResponseRelationFilter
  responseId: IntFilter
}

input AssertionResultsWhereUniqueInput {
  id: Int
}

enum AssertionScalarFieldEnum {
  comparison
  createdAt
  expected
  id
  property
  requestId
}

input AssertionScalarWhereInput {
  AND: [AssertionScalarWhereInput!]
  NOT: [AssertionScalarWhereInput!]
  OR: [AssertionScalarWhereInput!]
  comparison: StringFilter
  createdAt: DateTimeFilter
  expected: StringFilter
  id: IntFilter
  property: StringFilter
  requestId: IntFilter
}

input AssertionScalarWhereWithAggregatesInput {
  AND: [AssertionScalarWhereWithAggregatesInput!]
  NOT: [AssertionScalarWhereWithAggregatesInput!]
  OR: [AssertionScalarWhereWithAggregatesInput!]
  comparison: StringWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  expected: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  property: StringWithAggregatesFilter
  requestId: IntWithAggregatesFilter
}

type AssertionSumAggregate {
  id: Int
  requestId: Int
}

input AssertionSumOrderByAggregateInput {
  id: SortOrder
  requestId: SortOrder
}

input AssertionUpdateInput {
  AssertionResults: AssertionResultsUpdateManyWithoutAssertionNestedInput
  comparison: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  expected: StringFieldUpdateOperationsInput
  property: StringFieldUpdateOperationsInput
  request: RequestUpdateOneRequiredWithoutAssertionsNestedInput
}

input AssertionUpdateManyMutationInput {
  comparison: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  expected: StringFieldUpdateOperationsInput
  property: StringFieldUpdateOperationsInput
}

input AssertionUpdateManyWithWhereWithoutRequestInput {
  data: AssertionUpdateManyMutationInput!
  where: AssertionScalarWhereInput!
}

input AssertionUpdateManyWithoutRequestNestedInput {
  connect: [AssertionWhereUniqueInput!]
  connectOrCreate: [AssertionCreateOrConnectWithoutRequestInput!]
  create: [AssertionCreateWithoutRequestInput!]
  createMany: AssertionCreateManyRequestInputEnvelope
  delete: [AssertionWhereUniqueInput!]
  deleteMany: [AssertionScalarWhereInput!]
  disconnect: [AssertionWhereUniqueInput!]
  set: [AssertionWhereUniqueInput!]
  update: [AssertionUpdateWithWhereUniqueWithoutRequestInput!]
  updateMany: [AssertionUpdateManyWithWhereWithoutRequestInput!]
  upsert: [AssertionUpsertWithWhereUniqueWithoutRequestInput!]
}

input AssertionUpdateOneRequiredWithoutAssertionResultsNestedInput {
  connect: AssertionWhereUniqueInput
  connectOrCreate: AssertionCreateOrConnectWithoutAssertionResultsInput
  create: AssertionCreateWithoutAssertionResultsInput
  update: AssertionUpdateWithoutAssertionResultsInput
  upsert: AssertionUpsertWithoutAssertionResultsInput
}

input AssertionUpdateWithWhereUniqueWithoutRequestInput {
  data: AssertionUpdateWithoutRequestInput!
  where: AssertionWhereUniqueInput!
}

input AssertionUpdateWithoutAssertionResultsInput {
  comparison: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  expected: StringFieldUpdateOperationsInput
  property: StringFieldUpdateOperationsInput
  request: RequestUpdateOneRequiredWithoutAssertionsNestedInput
}

input AssertionUpdateWithoutRequestInput {
  AssertionResults: AssertionResultsUpdateManyWithoutAssertionNestedInput
  comparison: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  expected: StringFieldUpdateOperationsInput
  property: StringFieldUpdateOperationsInput
}

input AssertionUpsertWithWhereUniqueWithoutRequestInput {
  create: AssertionCreateWithoutRequestInput!
  update: AssertionUpdateWithoutRequestInput!
  where: AssertionWhereUniqueInput!
}

input AssertionUpsertWithoutAssertionResultsInput {
  create: AssertionCreateWithoutAssertionResultsInput!
  update: AssertionUpdateWithoutAssertionResultsInput!
}

input AssertionWhereInput {
  AND: [AssertionWhereInput!]
  AssertionResults: AssertionResultsListRelationFilter
  NOT: [AssertionWhereInput!]
  OR: [AssertionWhereInput!]
  comparison: StringFilter
  createdAt: DateTimeFilter
  expected: StringFilter
  id: IntFilter
  property: StringFilter
  request: RequestRelationFilter
  requestId: IntFilter
}

input AssertionWhereUniqueInput {
  id: Int
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input BoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

type Collection {
  CollectionRun(cursor: CollectionRunWhereUniqueInput, distinct: [CollectionRunScalarFieldEnum!], orderBy: [CollectionRunOrderByWithRelationInput!], skip: Int, take: Int, where: CollectionRunWhereInput): [CollectionRun!]!
  Monitor(cursor: MonitorWhereUniqueInput, distinct: [MonitorScalarFieldEnum!], orderBy: [MonitorOrderByWithRelationInput!], skip: Int, take: Int, where: MonitorWhereInput): [Monitor!]!
  _count: CollectionCount
  createdAt: DateTime!
  id: Int!
  requests(cursor: RequestWhereUniqueInput, distinct: [RequestScalarFieldEnum!], orderBy: [RequestOrderByWithRelationInput!], skip: Int, take: Int, where: RequestWhereInput): [Request!]!
  title: String!
}

type CollectionAvgAggregate {
  id: Float
}

input CollectionAvgOrderByAggregateInput {
  id: SortOrder
}

type CollectionCount {
  CollectionRun: Int!
  Monitor: Int!
  requests: Int!
}

type CollectionCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  title: Int!
}

input CollectionCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  title: SortOrder
}

input CollectionCreateInput {
  CollectionRun: CollectionRunCreateNestedManyWithoutCollectionInput
  Monitor: MonitorCreateNestedManyWithoutCollectionInput
  createdAt: DateTime
  requests: RequestCreateNestedManyWithoutCollectionInput
  title: String!
}

input CollectionCreateManyInput {
  createdAt: DateTime
  id: Int
  title: String!
}

input CollectionCreateNestedOneWithoutCollectionRunInput {
  connect: CollectionWhereUniqueInput
  connectOrCreate: CollectionCreateOrConnectWithoutCollectionRunInput
  create: CollectionCreateWithoutCollectionRunInput
}

input CollectionCreateNestedOneWithoutMonitorInput {
  connect: CollectionWhereUniqueInput
  connectOrCreate: CollectionCreateOrConnectWithoutMonitorInput
  create: CollectionCreateWithoutMonitorInput
}

input CollectionCreateNestedOneWithoutRequestsInput {
  connect: CollectionWhereUniqueInput
  connectOrCreate: CollectionCreateOrConnectWithoutRequestsInput
  create: CollectionCreateWithoutRequestsInput
}

input CollectionCreateOrConnectWithoutCollectionRunInput {
  create: CollectionCreateWithoutCollectionRunInput!
  where: CollectionWhereUniqueInput!
}

input CollectionCreateOrConnectWithoutMonitorInput {
  create: CollectionCreateWithoutMonitorInput!
  where: CollectionWhereUniqueInput!
}

input CollectionCreateOrConnectWithoutRequestsInput {
  create: CollectionCreateWithoutRequestsInput!
  where: CollectionWhereUniqueInput!
}

input CollectionCreateWithoutCollectionRunInput {
  Monitor: MonitorCreateNestedManyWithoutCollectionInput
  createdAt: DateTime
  requests: RequestCreateNestedManyWithoutCollectionInput
  title: String!
}

input CollectionCreateWithoutMonitorInput {
  CollectionRun: CollectionRunCreateNestedManyWithoutCollectionInput
  createdAt: DateTime
  requests: RequestCreateNestedManyWithoutCollectionInput
  title: String!
}

input CollectionCreateWithoutRequestsInput {
  CollectionRun: CollectionRunCreateNestedManyWithoutCollectionInput
  Monitor: MonitorCreateNestedManyWithoutCollectionInput
  createdAt: DateTime
  title: String!
}

type CollectionGroupBy {
  _avg: CollectionAvgAggregate
  _count: CollectionCountAggregate
  _max: CollectionMaxAggregate
  _min: CollectionMinAggregate
  _sum: CollectionSumAggregate
  createdAt: DateTime!
  id: Int!
  title: String!
}

type CollectionMaxAggregate {
  createdAt: DateTime
  id: Int
  title: String
}

input CollectionMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  title: SortOrder
}

type CollectionMinAggregate {
  createdAt: DateTime
  id: Int
  title: String
}

input CollectionMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  title: SortOrder
}

input CollectionOrderByWithAggregationInput {
  _avg: CollectionAvgOrderByAggregateInput
  _count: CollectionCountOrderByAggregateInput
  _max: CollectionMaxOrderByAggregateInput
  _min: CollectionMinOrderByAggregateInput
  _sum: CollectionSumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  title: SortOrder
}

input CollectionOrderByWithRelationInput {
  CollectionRun: CollectionRunOrderByRelationAggregateInput
  Monitor: MonitorOrderByRelationAggregateInput
  createdAt: SortOrder
  id: SortOrder
  requests: RequestOrderByRelationAggregateInput
  title: SortOrder
}

input CollectionRelationFilter {
  is: CollectionWhereInput
  isNot: CollectionWhereInput
}

type CollectionRun {
  Collection: Collection!
  Responses(cursor: ResponseWhereUniqueInput, distinct: [ResponseScalarFieldEnum!], orderBy: [ResponseOrderByWithRelationInput!], skip: Int, take: Int, where: ResponseWhereInput): [Response!]!
  _count: CollectionRunCount
  collectionId: Int!
  createdAt: DateTime!
  id: Int!
  success: Boolean!
}

type CollectionRunAvgAggregate {
  collectionId: Float
  id: Float
}

input CollectionRunAvgOrderByAggregateInput {
  collectionId: SortOrder
  id: SortOrder
}

type CollectionRunCount {
  Responses: Int!
}

type CollectionRunCountAggregate {
  _all: Int!
  collectionId: Int!
  createdAt: Int!
  id: Int!
  success: Int!
}

input CollectionRunCountOrderByAggregateInput {
  collectionId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  success: SortOrder
}

input CollectionRunCreateInput {
  Collection: CollectionCreateNestedOneWithoutCollectionRunInput!
  Responses: ResponseCreateNestedManyWithoutCollectionRunInput
  createdAt: DateTime
  success: Boolean!
}

input CollectionRunCreateManyCollectionInput {
  createdAt: DateTime
  id: Int
  success: Boolean!
}

input CollectionRunCreateManyCollectionInputEnvelope {
  data: [CollectionRunCreateManyCollectionInput!]!
  skipDuplicates: Boolean
}

input CollectionRunCreateManyInput {
  collectionId: Int!
  createdAt: DateTime
  id: Int
  success: Boolean!
}

input CollectionRunCreateNestedManyWithoutCollectionInput {
  connect: [CollectionRunWhereUniqueInput!]
  connectOrCreate: [CollectionRunCreateOrConnectWithoutCollectionInput!]
  create: [CollectionRunCreateWithoutCollectionInput!]
  createMany: CollectionRunCreateManyCollectionInputEnvelope
}

input CollectionRunCreateNestedOneWithoutResponsesInput {
  connect: CollectionRunWhereUniqueInput
  connectOrCreate: CollectionRunCreateOrConnectWithoutResponsesInput
  create: CollectionRunCreateWithoutResponsesInput
}

input CollectionRunCreateOrConnectWithoutCollectionInput {
  create: CollectionRunCreateWithoutCollectionInput!
  where: CollectionRunWhereUniqueInput!
}

input CollectionRunCreateOrConnectWithoutResponsesInput {
  create: CollectionRunCreateWithoutResponsesInput!
  where: CollectionRunWhereUniqueInput!
}

input CollectionRunCreateWithoutCollectionInput {
  Responses: ResponseCreateNestedManyWithoutCollectionRunInput
  createdAt: DateTime
  success: Boolean!
}

input CollectionRunCreateWithoutResponsesInput {
  Collection: CollectionCreateNestedOneWithoutCollectionRunInput!
  createdAt: DateTime
  success: Boolean!
}

type CollectionRunGroupBy {
  _avg: CollectionRunAvgAggregate
  _count: CollectionRunCountAggregate
  _max: CollectionRunMaxAggregate
  _min: CollectionRunMinAggregate
  _sum: CollectionRunSumAggregate
  collectionId: Int!
  createdAt: DateTime!
  id: Int!
  success: Boolean!
}

input CollectionRunListRelationFilter {
  every: CollectionRunWhereInput
  none: CollectionRunWhereInput
  some: CollectionRunWhereInput
}

type CollectionRunMaxAggregate {
  collectionId: Int
  createdAt: DateTime
  id: Int
  success: Boolean
}

input CollectionRunMaxOrderByAggregateInput {
  collectionId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  success: SortOrder
}

type CollectionRunMinAggregate {
  collectionId: Int
  createdAt: DateTime
  id: Int
  success: Boolean
}

input CollectionRunMinOrderByAggregateInput {
  collectionId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  success: SortOrder
}

input CollectionRunOrderByRelationAggregateInput {
  _count: SortOrder
}

input CollectionRunOrderByWithAggregationInput {
  _avg: CollectionRunAvgOrderByAggregateInput
  _count: CollectionRunCountOrderByAggregateInput
  _max: CollectionRunMaxOrderByAggregateInput
  _min: CollectionRunMinOrderByAggregateInput
  _sum: CollectionRunSumOrderByAggregateInput
  collectionId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  success: SortOrder
}

input CollectionRunOrderByWithRelationInput {
  Collection: CollectionOrderByWithRelationInput
  Responses: ResponseOrderByRelationAggregateInput
  collectionId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  success: SortOrder
}

input CollectionRunRelationFilter {
  is: CollectionRunWhereInput
  isNot: CollectionRunWhereInput
}

enum CollectionRunScalarFieldEnum {
  collectionId
  createdAt
  id
  success
}

input CollectionRunScalarWhereInput {
  AND: [CollectionRunScalarWhereInput!]
  NOT: [CollectionRunScalarWhereInput!]
  OR: [CollectionRunScalarWhereInput!]
  collectionId: IntFilter
  createdAt: DateTimeFilter
  id: IntFilter
  success: BoolFilter
}

input CollectionRunScalarWhereWithAggregatesInput {
  AND: [CollectionRunScalarWhereWithAggregatesInput!]
  NOT: [CollectionRunScalarWhereWithAggregatesInput!]
  OR: [CollectionRunScalarWhereWithAggregatesInput!]
  collectionId: IntWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  success: BoolWithAggregatesFilter
}

type CollectionRunSumAggregate {
  collectionId: Int
  id: Int
}

input CollectionRunSumOrderByAggregateInput {
  collectionId: SortOrder
  id: SortOrder
}

input CollectionRunUpdateInput {
  Collection: CollectionUpdateOneRequiredWithoutCollectionRunNestedInput
  Responses: ResponseUpdateManyWithoutCollectionRunNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  success: BoolFieldUpdateOperationsInput
}

input CollectionRunUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  success: BoolFieldUpdateOperationsInput
}

input CollectionRunUpdateManyWithWhereWithoutCollectionInput {
  data: CollectionRunUpdateManyMutationInput!
  where: CollectionRunScalarWhereInput!
}

input CollectionRunUpdateManyWithoutCollectionNestedInput {
  connect: [CollectionRunWhereUniqueInput!]
  connectOrCreate: [CollectionRunCreateOrConnectWithoutCollectionInput!]
  create: [CollectionRunCreateWithoutCollectionInput!]
  createMany: CollectionRunCreateManyCollectionInputEnvelope
  delete: [CollectionRunWhereUniqueInput!]
  deleteMany: [CollectionRunScalarWhereInput!]
  disconnect: [CollectionRunWhereUniqueInput!]
  set: [CollectionRunWhereUniqueInput!]
  update: [CollectionRunUpdateWithWhereUniqueWithoutCollectionInput!]
  updateMany: [CollectionRunUpdateManyWithWhereWithoutCollectionInput!]
  upsert: [CollectionRunUpsertWithWhereUniqueWithoutCollectionInput!]
}

input CollectionRunUpdateOneWithoutResponsesNestedInput {
  connect: CollectionRunWhereUniqueInput
  connectOrCreate: CollectionRunCreateOrConnectWithoutResponsesInput
  create: CollectionRunCreateWithoutResponsesInput
  delete: Boolean
  disconnect: Boolean
  update: CollectionRunUpdateWithoutResponsesInput
  upsert: CollectionRunUpsertWithoutResponsesInput
}

input CollectionRunUpdateWithWhereUniqueWithoutCollectionInput {
  data: CollectionRunUpdateWithoutCollectionInput!
  where: CollectionRunWhereUniqueInput!
}

input CollectionRunUpdateWithoutCollectionInput {
  Responses: ResponseUpdateManyWithoutCollectionRunNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  success: BoolFieldUpdateOperationsInput
}

input CollectionRunUpdateWithoutResponsesInput {
  Collection: CollectionUpdateOneRequiredWithoutCollectionRunNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  success: BoolFieldUpdateOperationsInput
}

input CollectionRunUpsertWithWhereUniqueWithoutCollectionInput {
  create: CollectionRunCreateWithoutCollectionInput!
  update: CollectionRunUpdateWithoutCollectionInput!
  where: CollectionRunWhereUniqueInput!
}

input CollectionRunUpsertWithoutResponsesInput {
  create: CollectionRunCreateWithoutResponsesInput!
  update: CollectionRunUpdateWithoutResponsesInput!
}

input CollectionRunWhereInput {
  AND: [CollectionRunWhereInput!]
  Collection: CollectionRelationFilter
  NOT: [CollectionRunWhereInput!]
  OR: [CollectionRunWhereInput!]
  Responses: ResponseListRelationFilter
  collectionId: IntFilter
  createdAt: DateTimeFilter
  id: IntFilter
  success: BoolFilter
}

input CollectionRunWhereUniqueInput {
  id: Int
}

enum CollectionScalarFieldEnum {
  createdAt
  id
  title
}

input CollectionScalarWhereWithAggregatesInput {
  AND: [CollectionScalarWhereWithAggregatesInput!]
  NOT: [CollectionScalarWhereWithAggregatesInput!]
  OR: [CollectionScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  title: StringWithAggregatesFilter
}

type CollectionSumAggregate {
  id: Int
}

input CollectionSumOrderByAggregateInput {
  id: SortOrder
}

input CollectionUpdateInput {
  CollectionRun: CollectionRunUpdateManyWithoutCollectionNestedInput
  Monitor: MonitorUpdateManyWithoutCollectionNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  requests: RequestUpdateManyWithoutCollectionNestedInput
  title: StringFieldUpdateOperationsInput
}

input CollectionUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input CollectionUpdateOneRequiredWithoutCollectionRunNestedInput {
  connect: CollectionWhereUniqueInput
  connectOrCreate: CollectionCreateOrConnectWithoutCollectionRunInput
  create: CollectionCreateWithoutCollectionRunInput
  update: CollectionUpdateWithoutCollectionRunInput
  upsert: CollectionUpsertWithoutCollectionRunInput
}

input CollectionUpdateOneRequiredWithoutMonitorNestedInput {
  connect: CollectionWhereUniqueInput
  connectOrCreate: CollectionCreateOrConnectWithoutMonitorInput
  create: CollectionCreateWithoutMonitorInput
  update: CollectionUpdateWithoutMonitorInput
  upsert: CollectionUpsertWithoutMonitorInput
}

input CollectionUpdateOneRequiredWithoutRequestsNestedInput {
  connect: CollectionWhereUniqueInput
  connectOrCreate: CollectionCreateOrConnectWithoutRequestsInput
  create: CollectionCreateWithoutRequestsInput
  update: CollectionUpdateWithoutRequestsInput
  upsert: CollectionUpsertWithoutRequestsInput
}

input CollectionUpdateWithoutCollectionRunInput {
  Monitor: MonitorUpdateManyWithoutCollectionNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  requests: RequestUpdateManyWithoutCollectionNestedInput
  title: StringFieldUpdateOperationsInput
}

input CollectionUpdateWithoutMonitorInput {
  CollectionRun: CollectionRunUpdateManyWithoutCollectionNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  requests: RequestUpdateManyWithoutCollectionNestedInput
  title: StringFieldUpdateOperationsInput
}

input CollectionUpdateWithoutRequestsInput {
  CollectionRun: CollectionRunUpdateManyWithoutCollectionNestedInput
  Monitor: MonitorUpdateManyWithoutCollectionNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input CollectionUpsertWithoutCollectionRunInput {
  create: CollectionCreateWithoutCollectionRunInput!
  update: CollectionUpdateWithoutCollectionRunInput!
}

input CollectionUpsertWithoutMonitorInput {
  create: CollectionCreateWithoutMonitorInput!
  update: CollectionUpdateWithoutMonitorInput!
}

input CollectionUpsertWithoutRequestsInput {
  create: CollectionCreateWithoutRequestsInput!
  update: CollectionUpdateWithoutRequestsInput!
}

input CollectionWhereInput {
  AND: [CollectionWhereInput!]
  CollectionRun: CollectionRunListRelationFilter
  Monitor: MonitorListRelationFilter
  NOT: [CollectionWhereInput!]
  OR: [CollectionWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  requests: RequestListRelationFilter
  title: StringFilter
}

input CollectionWhereUniqueInput {
  id: Int
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input IntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

input JsonFilter {
  array_contains: JSON
  array_ends_with: JSON
  array_starts_with: JSON
  equals: JSON
  gt: JSON
  gte: JSON
  lt: JSON
  lte: JSON
  not: JSON
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

input JsonNullableFilter {
  array_contains: JSON
  array_ends_with: JSON
  array_starts_with: JSON
  equals: JSON
  gt: JSON
  gte: JSON
  lt: JSON
  lte: JSON
  not: JSON
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

input JsonNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedJsonNullableFilter
  _min: NestedJsonNullableFilter
  array_contains: JSON
  array_ends_with: JSON
  array_starts_with: JSON
  equals: JSON
  gt: JSON
  gte: JSON
  lt: JSON
  lte: JSON
  not: JSON
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

input JsonWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedJsonFilter
  _min: NestedJsonFilter
  array_contains: JSON
  array_ends_with: JSON
  array_starts_with: JSON
  equals: JSON
  gt: JSON
  gte: JSON
  lt: JSON
  lte: JSON
  not: JSON
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

type Monitor {
  collection: Collection!
  collectionId: Int!
  createdAt: DateTime!
  env: String!
  id: Int!
  schedule: String!
}

type MonitorAvgAggregate {
  collectionId: Float
  id: Float
}

input MonitorAvgOrderByAggregateInput {
  collectionId: SortOrder
  id: SortOrder
}

type MonitorCountAggregate {
  _all: Int!
  collectionId: Int!
  createdAt: Int!
  env: Int!
  id: Int!
  schedule: Int!
}

input MonitorCountOrderByAggregateInput {
  collectionId: SortOrder
  createdAt: SortOrder
  env: SortOrder
  id: SortOrder
  schedule: SortOrder
}

input MonitorCreateInput {
  collection: CollectionCreateNestedOneWithoutMonitorInput!
  createdAt: DateTime
  env: String!
  schedule: String!
}

input MonitorCreateManyCollectionInput {
  createdAt: DateTime
  env: String!
  id: Int
  schedule: String!
}

input MonitorCreateManyCollectionInputEnvelope {
  data: [MonitorCreateManyCollectionInput!]!
  skipDuplicates: Boolean
}

input MonitorCreateManyInput {
  collectionId: Int!
  createdAt: DateTime
  env: String!
  id: Int
  schedule: String!
}

input MonitorCreateNestedManyWithoutCollectionInput {
  connect: [MonitorWhereUniqueInput!]
  connectOrCreate: [MonitorCreateOrConnectWithoutCollectionInput!]
  create: [MonitorCreateWithoutCollectionInput!]
  createMany: MonitorCreateManyCollectionInputEnvelope
}

input MonitorCreateOrConnectWithoutCollectionInput {
  create: MonitorCreateWithoutCollectionInput!
  where: MonitorWhereUniqueInput!
}

input MonitorCreateWithoutCollectionInput {
  createdAt: DateTime
  env: String!
  schedule: String!
}

type MonitorGroupBy {
  _avg: MonitorAvgAggregate
  _count: MonitorCountAggregate
  _max: MonitorMaxAggregate
  _min: MonitorMinAggregate
  _sum: MonitorSumAggregate
  collectionId: Int!
  createdAt: DateTime!
  env: String!
  id: Int!
  schedule: String!
}

input MonitorListRelationFilter {
  every: MonitorWhereInput
  none: MonitorWhereInput
  some: MonitorWhereInput
}

type MonitorMaxAggregate {
  collectionId: Int
  createdAt: DateTime
  env: String
  id: Int
  schedule: String
}

input MonitorMaxOrderByAggregateInput {
  collectionId: SortOrder
  createdAt: SortOrder
  env: SortOrder
  id: SortOrder
  schedule: SortOrder
}

type MonitorMinAggregate {
  collectionId: Int
  createdAt: DateTime
  env: String
  id: Int
  schedule: String
}

input MonitorMinOrderByAggregateInput {
  collectionId: SortOrder
  createdAt: SortOrder
  env: SortOrder
  id: SortOrder
  schedule: SortOrder
}

input MonitorOrderByRelationAggregateInput {
  _count: SortOrder
}

input MonitorOrderByWithAggregationInput {
  _avg: MonitorAvgOrderByAggregateInput
  _count: MonitorCountOrderByAggregateInput
  _max: MonitorMaxOrderByAggregateInput
  _min: MonitorMinOrderByAggregateInput
  _sum: MonitorSumOrderByAggregateInput
  collectionId: SortOrder
  createdAt: SortOrder
  env: SortOrder
  id: SortOrder
  schedule: SortOrder
}

input MonitorOrderByWithRelationInput {
  collection: CollectionOrderByWithRelationInput
  collectionId: SortOrder
  createdAt: SortOrder
  env: SortOrder
  id: SortOrder
  schedule: SortOrder
}

enum MonitorScalarFieldEnum {
  collectionId
  createdAt
  env
  id
  schedule
}

input MonitorScalarWhereInput {
  AND: [MonitorScalarWhereInput!]
  NOT: [MonitorScalarWhereInput!]
  OR: [MonitorScalarWhereInput!]
  collectionId: IntFilter
  createdAt: DateTimeFilter
  env: StringFilter
  id: IntFilter
  schedule: StringFilter
}

input MonitorScalarWhereWithAggregatesInput {
  AND: [MonitorScalarWhereWithAggregatesInput!]
  NOT: [MonitorScalarWhereWithAggregatesInput!]
  OR: [MonitorScalarWhereWithAggregatesInput!]
  collectionId: IntWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  env: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  schedule: StringWithAggregatesFilter
}

type MonitorSumAggregate {
  collectionId: Int
  id: Int
}

input MonitorSumOrderByAggregateInput {
  collectionId: SortOrder
  id: SortOrder
}

input MonitorUpdateInput {
  collection: CollectionUpdateOneRequiredWithoutMonitorNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  env: StringFieldUpdateOperationsInput
  schedule: StringFieldUpdateOperationsInput
}

input MonitorUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  env: StringFieldUpdateOperationsInput
  schedule: StringFieldUpdateOperationsInput
}

input MonitorUpdateManyWithWhereWithoutCollectionInput {
  data: MonitorUpdateManyMutationInput!
  where: MonitorScalarWhereInput!
}

input MonitorUpdateManyWithoutCollectionNestedInput {
  connect: [MonitorWhereUniqueInput!]
  connectOrCreate: [MonitorCreateOrConnectWithoutCollectionInput!]
  create: [MonitorCreateWithoutCollectionInput!]
  createMany: MonitorCreateManyCollectionInputEnvelope
  delete: [MonitorWhereUniqueInput!]
  deleteMany: [MonitorScalarWhereInput!]
  disconnect: [MonitorWhereUniqueInput!]
  set: [MonitorWhereUniqueInput!]
  update: [MonitorUpdateWithWhereUniqueWithoutCollectionInput!]
  updateMany: [MonitorUpdateManyWithWhereWithoutCollectionInput!]
  upsert: [MonitorUpsertWithWhereUniqueWithoutCollectionInput!]
}

input MonitorUpdateWithWhereUniqueWithoutCollectionInput {
  data: MonitorUpdateWithoutCollectionInput!
  where: MonitorWhereUniqueInput!
}

input MonitorUpdateWithoutCollectionInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  env: StringFieldUpdateOperationsInput
  schedule: StringFieldUpdateOperationsInput
}

input MonitorUpsertWithWhereUniqueWithoutCollectionInput {
  create: MonitorCreateWithoutCollectionInput!
  update: MonitorUpdateWithoutCollectionInput!
  where: MonitorWhereUniqueInput!
}

input MonitorWhereInput {
  AND: [MonitorWhereInput!]
  NOT: [MonitorWhereInput!]
  OR: [MonitorWhereInput!]
  collection: CollectionRelationFilter
  collectionId: IntFilter
  createdAt: DateTimeFilter
  env: StringFilter
  id: IntFilter
  schedule: StringFilter
}

input MonitorWhereUniqueInput {
  id: Int
}

type Mutation {
  createManyAssertion(data: [AssertionCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyAssertionResults(data: [AssertionResultsCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyCollection(data: [CollectionCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyCollectionRun(data: [CollectionRunCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyMonitor(data: [MonitorCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyRequest(data: [RequestCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyResponse(data: [ResponseCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOneAssertion(data: AssertionCreateInput!): Assertion!
  createOneAssertionResults(data: AssertionResultsCreateInput!): AssertionResults!
  createOneCollection(data: CollectionCreateInput!): Collection!
  createOneCollectionRun(data: CollectionRunCreateInput!): CollectionRun!
  createOneMonitor(data: MonitorCreateInput!): Monitor!
  createOneRequest(data: RequestCreateInput!): Request!
  createOneResponse(data: ResponseCreateInput!): Response!
  deleteManyAssertion(where: AssertionWhereInput): AffectedRowsOutput!
  deleteManyAssertionResults(where: AssertionResultsWhereInput): AffectedRowsOutput!
  deleteManyCollection(where: CollectionWhereInput): AffectedRowsOutput!
  deleteManyCollectionRun(where: CollectionRunWhereInput): AffectedRowsOutput!
  deleteManyMonitor(where: MonitorWhereInput): AffectedRowsOutput!
  deleteManyRequest(where: RequestWhereInput): AffectedRowsOutput!
  deleteManyResponse(where: ResponseWhereInput): AffectedRowsOutput!
  deleteOneAssertion(where: AssertionWhereUniqueInput!): Assertion
  deleteOneAssertionResults(where: AssertionResultsWhereUniqueInput!): AssertionResults
  deleteOneCollection(where: CollectionWhereUniqueInput!): Collection
  deleteOneCollectionRun(where: CollectionRunWhereUniqueInput!): CollectionRun
  deleteOneMonitor(where: MonitorWhereUniqueInput!): Monitor
  deleteOneRequest(where: RequestWhereUniqueInput!): Request
  deleteOneResponse(where: ResponseWhereUniqueInput!): Response
  updateManyAssertion(data: AssertionUpdateManyMutationInput!, where: AssertionWhereInput): AffectedRowsOutput!
  updateManyAssertionResults(data: AssertionResultsUpdateManyMutationInput!, where: AssertionResultsWhereInput): AffectedRowsOutput!
  updateManyCollection(data: CollectionUpdateManyMutationInput!, where: CollectionWhereInput): AffectedRowsOutput!
  updateManyCollectionRun(data: CollectionRunUpdateManyMutationInput!, where: CollectionRunWhereInput): AffectedRowsOutput!
  updateManyMonitor(data: MonitorUpdateManyMutationInput!, where: MonitorWhereInput): AffectedRowsOutput!
  updateManyRequest(data: RequestUpdateManyMutationInput!, where: RequestWhereInput): AffectedRowsOutput!
  updateManyResponse(data: ResponseUpdateManyMutationInput!, where: ResponseWhereInput): AffectedRowsOutput!
  updateOneAssertion(data: AssertionUpdateInput!, where: AssertionWhereUniqueInput!): Assertion
  updateOneAssertionResults(data: AssertionResultsUpdateInput!, where: AssertionResultsWhereUniqueInput!): AssertionResults
  updateOneCollection(data: CollectionUpdateInput!, where: CollectionWhereUniqueInput!): Collection
  updateOneCollectionRun(data: CollectionRunUpdateInput!, where: CollectionRunWhereUniqueInput!): CollectionRun
  updateOneMonitor(data: MonitorUpdateInput!, where: MonitorWhereUniqueInput!): Monitor
  updateOneRequest(data: RequestUpdateInput!, where: RequestWhereUniqueInput!): Request
  updateOneResponse(data: ResponseUpdateInput!, where: ResponseWhereUniqueInput!): Response
  upsertOneAssertion(create: AssertionCreateInput!, update: AssertionUpdateInput!, where: AssertionWhereUniqueInput!): Assertion!
  upsertOneAssertionResults(create: AssertionResultsCreateInput!, update: AssertionResultsUpdateInput!, where: AssertionResultsWhereUniqueInput!): AssertionResults!
  upsertOneCollection(create: CollectionCreateInput!, update: CollectionUpdateInput!, where: CollectionWhereUniqueInput!): Collection!
  upsertOneCollectionRun(create: CollectionRunCreateInput!, update: CollectionRunUpdateInput!, where: CollectionRunWhereUniqueInput!): CollectionRun!
  upsertOneMonitor(create: MonitorCreateInput!, update: MonitorUpdateInput!, where: MonitorWhereUniqueInput!): Monitor!
  upsertOneRequest(create: RequestCreateInput!, update: RequestUpdateInput!, where: RequestWhereUniqueInput!): Request!
  upsertOneResponse(create: ResponseCreateInput!, update: ResponseUpdateInput!, where: ResponseWhereUniqueInput!): Response!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedJsonFilter {
  array_contains: JSON
  array_ends_with: JSON
  array_starts_with: JSON
  equals: JSON
  gt: JSON
  gte: JSON
  lt: JSON
  lte: JSON
  not: JSON
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

input NestedJsonNullableFilter {
  array_contains: JSON
  array_ends_with: JSON
  array_starts_with: JSON
  equals: JSON
  gt: JSON
  gte: JSON
  lt: JSON
  lte: JSON
  not: JSON
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Query {
  aggregateAssertion(cursor: AssertionWhereUniqueInput, orderBy: [AssertionOrderByWithRelationInput!], skip: Int, take: Int, where: AssertionWhereInput): AggregateAssertion!
  aggregateAssertionResults(cursor: AssertionResultsWhereUniqueInput, orderBy: [AssertionResultsOrderByWithRelationInput!], skip: Int, take: Int, where: AssertionResultsWhereInput): AggregateAssertionResults!
  aggregateCollection(cursor: CollectionWhereUniqueInput, orderBy: [CollectionOrderByWithRelationInput!], skip: Int, take: Int, where: CollectionWhereInput): AggregateCollection!
  aggregateCollectionRun(cursor: CollectionRunWhereUniqueInput, orderBy: [CollectionRunOrderByWithRelationInput!], skip: Int, take: Int, where: CollectionRunWhereInput): AggregateCollectionRun!
  aggregateMonitor(cursor: MonitorWhereUniqueInput, orderBy: [MonitorOrderByWithRelationInput!], skip: Int, take: Int, where: MonitorWhereInput): AggregateMonitor!
  aggregateRequest(cursor: RequestWhereUniqueInput, orderBy: [RequestOrderByWithRelationInput!], skip: Int, take: Int, where: RequestWhereInput): AggregateRequest!
  aggregateResponse(cursor: ResponseWhereUniqueInput, orderBy: [ResponseOrderByWithRelationInput!], skip: Int, take: Int, where: ResponseWhereInput): AggregateResponse!
  assertion(where: AssertionWhereUniqueInput!): Assertion
  assertions(cursor: AssertionWhereUniqueInput, distinct: [AssertionScalarFieldEnum!], orderBy: [AssertionOrderByWithRelationInput!], skip: Int, take: Int, where: AssertionWhereInput): [Assertion!]!
  collection(where: CollectionWhereUniqueInput!): Collection
  collectionRun(where: CollectionRunWhereUniqueInput!): CollectionRun
  collectionRuns(cursor: CollectionRunWhereUniqueInput, distinct: [CollectionRunScalarFieldEnum!], orderBy: [CollectionRunOrderByWithRelationInput!], skip: Int, take: Int, where: CollectionRunWhereInput): [CollectionRun!]!
  collections(cursor: CollectionWhereUniqueInput, distinct: [CollectionScalarFieldEnum!], orderBy: [CollectionOrderByWithRelationInput!], skip: Int, take: Int, where: CollectionWhereInput): [Collection!]!
  findFirstAssertion(cursor: AssertionWhereUniqueInput, distinct: [AssertionScalarFieldEnum!], orderBy: [AssertionOrderByWithRelationInput!], skip: Int, take: Int, where: AssertionWhereInput): Assertion
  findFirstAssertionResults(cursor: AssertionResultsWhereUniqueInput, distinct: [AssertionResultsScalarFieldEnum!], orderBy: [AssertionResultsOrderByWithRelationInput!], skip: Int, take: Int, where: AssertionResultsWhereInput): AssertionResults
  findFirstCollection(cursor: CollectionWhereUniqueInput, distinct: [CollectionScalarFieldEnum!], orderBy: [CollectionOrderByWithRelationInput!], skip: Int, take: Int, where: CollectionWhereInput): Collection
  findFirstCollectionRun(cursor: CollectionRunWhereUniqueInput, distinct: [CollectionRunScalarFieldEnum!], orderBy: [CollectionRunOrderByWithRelationInput!], skip: Int, take: Int, where: CollectionRunWhereInput): CollectionRun
  findFirstMonitor(cursor: MonitorWhereUniqueInput, distinct: [MonitorScalarFieldEnum!], orderBy: [MonitorOrderByWithRelationInput!], skip: Int, take: Int, where: MonitorWhereInput): Monitor
  findFirstRequest(cursor: RequestWhereUniqueInput, distinct: [RequestScalarFieldEnum!], orderBy: [RequestOrderByWithRelationInput!], skip: Int, take: Int, where: RequestWhereInput): Request
  findFirstResponse(cursor: ResponseWhereUniqueInput, distinct: [ResponseScalarFieldEnum!], orderBy: [ResponseOrderByWithRelationInput!], skip: Int, take: Int, where: ResponseWhereInput): Response
  findManyAssertionResults(cursor: AssertionResultsWhereUniqueInput, distinct: [AssertionResultsScalarFieldEnum!], orderBy: [AssertionResultsOrderByWithRelationInput!], skip: Int, take: Int, where: AssertionResultsWhereInput): [AssertionResults!]!
  findUniqueAssertionResults(where: AssertionResultsWhereUniqueInput!): AssertionResults
  groupByAssertion(by: [AssertionScalarFieldEnum!]!, having: AssertionScalarWhereWithAggregatesInput, orderBy: [AssertionOrderByWithAggregationInput!], skip: Int, take: Int, where: AssertionWhereInput): [AssertionGroupBy!]!
  groupByAssertionResults(by: [AssertionResultsScalarFieldEnum!]!, having: AssertionResultsScalarWhereWithAggregatesInput, orderBy: [AssertionResultsOrderByWithAggregationInput!], skip: Int, take: Int, where: AssertionResultsWhereInput): [AssertionResultsGroupBy!]!
  groupByCollection(by: [CollectionScalarFieldEnum!]!, having: CollectionScalarWhereWithAggregatesInput, orderBy: [CollectionOrderByWithAggregationInput!], skip: Int, take: Int, where: CollectionWhereInput): [CollectionGroupBy!]!
  groupByCollectionRun(by: [CollectionRunScalarFieldEnum!]!, having: CollectionRunScalarWhereWithAggregatesInput, orderBy: [CollectionRunOrderByWithAggregationInput!], skip: Int, take: Int, where: CollectionRunWhereInput): [CollectionRunGroupBy!]!
  groupByMonitor(by: [MonitorScalarFieldEnum!]!, having: MonitorScalarWhereWithAggregatesInput, orderBy: [MonitorOrderByWithAggregationInput!], skip: Int, take: Int, where: MonitorWhereInput): [MonitorGroupBy!]!
  groupByRequest(by: [RequestScalarFieldEnum!]!, having: RequestScalarWhereWithAggregatesInput, orderBy: [RequestOrderByWithAggregationInput!], skip: Int, take: Int, where: RequestWhereInput): [RequestGroupBy!]!
  groupByResponse(by: [ResponseScalarFieldEnum!]!, having: ResponseScalarWhereWithAggregatesInput, orderBy: [ResponseOrderByWithAggregationInput!], skip: Int, take: Int, where: ResponseWhereInput): [ResponseGroupBy!]!
  monitor(where: MonitorWhereUniqueInput!): Monitor
  monitors(cursor: MonitorWhereUniqueInput, distinct: [MonitorScalarFieldEnum!], orderBy: [MonitorOrderByWithRelationInput!], skip: Int, take: Int, where: MonitorWhereInput): [Monitor!]!
  request(where: RequestWhereUniqueInput!): Request
  requests(cursor: RequestWhereUniqueInput, distinct: [RequestScalarFieldEnum!], orderBy: [RequestOrderByWithRelationInput!], skip: Int, take: Int, where: RequestWhereInput): [Request!]!
  response(where: ResponseWhereUniqueInput!): Response
  responses(cursor: ResponseWhereUniqueInput, distinct: [ResponseScalarFieldEnum!], orderBy: [ResponseOrderByWithRelationInput!], skip: Int, take: Int, where: ResponseWhereInput): [Response!]!
}

enum QueryMode {
  default
  insensitive
}

type Request {
  _count: RequestCount
  assertions(cursor: AssertionWhereUniqueInput, distinct: [AssertionScalarFieldEnum!], orderBy: [AssertionOrderByWithRelationInput!], skip: Int, take: Int, where: AssertionWhereInput): [Assertion!]!
  body: JSON
  collection: Collection!
  collectionId: Int!
  createdAt: DateTime!
  headers: JSON
  id: Int!
  method: String!
  responses(cursor: ResponseWhereUniqueInput, distinct: [ResponseScalarFieldEnum!], orderBy: [ResponseOrderByWithRelationInput!], skip: Int, take: Int, where: ResponseWhereInput): [Response!]!
  stepNumber: Int!
  title: String!
  url: String!
}

type RequestAvgAggregate {
  collectionId: Float
  id: Float
  stepNumber: Float
}

input RequestAvgOrderByAggregateInput {
  collectionId: SortOrder
  id: SortOrder
  stepNumber: SortOrder
}

type RequestCount {
  assertions: Int!
  responses: Int!
}

type RequestCountAggregate {
  _all: Int!
  body: Int!
  collectionId: Int!
  createdAt: Int!
  headers: Int!
  id: Int!
  method: Int!
  stepNumber: Int!
  title: Int!
  url: Int!
}

input RequestCountOrderByAggregateInput {
  body: SortOrder
  collectionId: SortOrder
  createdAt: SortOrder
  headers: SortOrder
  id: SortOrder
  method: SortOrder
  stepNumber: SortOrder
  title: SortOrder
  url: SortOrder
}

input RequestCreateInput {
  assertions: AssertionCreateNestedManyWithoutRequestInput
  body: JSON
  collection: CollectionCreateNestedOneWithoutRequestsInput!
  createdAt: DateTime
  headers: JSON
  method: String!
  responses: ResponseCreateNestedManyWithoutRequestInput
  stepNumber: Int!
  title: String!
  url: String!
}

input RequestCreateManyCollectionInput {
  body: JSON
  createdAt: DateTime
  headers: JSON
  id: Int
  method: String!
  stepNumber: Int!
  title: String!
  url: String!
}

input RequestCreateManyCollectionInputEnvelope {
  data: [RequestCreateManyCollectionInput!]!
  skipDuplicates: Boolean
}

input RequestCreateManyInput {
  body: JSON
  collectionId: Int!
  createdAt: DateTime
  headers: JSON
  id: Int
  method: String!
  stepNumber: Int!
  title: String!
  url: String!
}

input RequestCreateNestedManyWithoutCollectionInput {
  connect: [RequestWhereUniqueInput!]
  connectOrCreate: [RequestCreateOrConnectWithoutCollectionInput!]
  create: [RequestCreateWithoutCollectionInput!]
  createMany: RequestCreateManyCollectionInputEnvelope
}

input RequestCreateNestedOneWithoutAssertionsInput {
  connect: RequestWhereUniqueInput
  connectOrCreate: RequestCreateOrConnectWithoutAssertionsInput
  create: RequestCreateWithoutAssertionsInput
}

input RequestCreateNestedOneWithoutResponsesInput {
  connect: RequestWhereUniqueInput
  connectOrCreate: RequestCreateOrConnectWithoutResponsesInput
  create: RequestCreateWithoutResponsesInput
}

input RequestCreateOrConnectWithoutAssertionsInput {
  create: RequestCreateWithoutAssertionsInput!
  where: RequestWhereUniqueInput!
}

input RequestCreateOrConnectWithoutCollectionInput {
  create: RequestCreateWithoutCollectionInput!
  where: RequestWhereUniqueInput!
}

input RequestCreateOrConnectWithoutResponsesInput {
  create: RequestCreateWithoutResponsesInput!
  where: RequestWhereUniqueInput!
}

input RequestCreateWithoutAssertionsInput {
  body: JSON
  collection: CollectionCreateNestedOneWithoutRequestsInput!
  createdAt: DateTime
  headers: JSON
  method: String!
  responses: ResponseCreateNestedManyWithoutRequestInput
  stepNumber: Int!
  title: String!
  url: String!
}

input RequestCreateWithoutCollectionInput {
  assertions: AssertionCreateNestedManyWithoutRequestInput
  body: JSON
  createdAt: DateTime
  headers: JSON
  method: String!
  responses: ResponseCreateNestedManyWithoutRequestInput
  stepNumber: Int!
  title: String!
  url: String!
}

input RequestCreateWithoutResponsesInput {
  assertions: AssertionCreateNestedManyWithoutRequestInput
  body: JSON
  collection: CollectionCreateNestedOneWithoutRequestsInput!
  createdAt: DateTime
  headers: JSON
  method: String!
  stepNumber: Int!
  title: String!
  url: String!
}

type RequestGroupBy {
  _avg: RequestAvgAggregate
  _count: RequestCountAggregate
  _max: RequestMaxAggregate
  _min: RequestMinAggregate
  _sum: RequestSumAggregate
  body: JSON
  collectionId: Int!
  createdAt: DateTime!
  headers: JSON
  id: Int!
  method: String!
  stepNumber: Int!
  title: String!
  url: String!
}

input RequestListRelationFilter {
  every: RequestWhereInput
  none: RequestWhereInput
  some: RequestWhereInput
}

type RequestMaxAggregate {
  collectionId: Int
  createdAt: DateTime
  id: Int
  method: String
  stepNumber: Int
  title: String
  url: String
}

input RequestMaxOrderByAggregateInput {
  collectionId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  method: SortOrder
  stepNumber: SortOrder
  title: SortOrder
  url: SortOrder
}

type RequestMinAggregate {
  collectionId: Int
  createdAt: DateTime
  id: Int
  method: String
  stepNumber: Int
  title: String
  url: String
}

input RequestMinOrderByAggregateInput {
  collectionId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  method: SortOrder
  stepNumber: SortOrder
  title: SortOrder
  url: SortOrder
}

input RequestOrderByRelationAggregateInput {
  _count: SortOrder
}

input RequestOrderByWithAggregationInput {
  _avg: RequestAvgOrderByAggregateInput
  _count: RequestCountOrderByAggregateInput
  _max: RequestMaxOrderByAggregateInput
  _min: RequestMinOrderByAggregateInput
  _sum: RequestSumOrderByAggregateInput
  body: SortOrder
  collectionId: SortOrder
  createdAt: SortOrder
  headers: SortOrder
  id: SortOrder
  method: SortOrder
  stepNumber: SortOrder
  title: SortOrder
  url: SortOrder
}

input RequestOrderByWithRelationInput {
  assertions: AssertionOrderByRelationAggregateInput
  body: SortOrder
  collection: CollectionOrderByWithRelationInput
  collectionId: SortOrder
  createdAt: SortOrder
  headers: SortOrder
  id: SortOrder
  method: SortOrder
  responses: ResponseOrderByRelationAggregateInput
  stepNumber: SortOrder
  title: SortOrder
  url: SortOrder
}

input RequestRelationFilter {
  is: RequestWhereInput
  isNot: RequestWhereInput
}

enum RequestScalarFieldEnum {
  body
  collectionId
  createdAt
  headers
  id
  method
  stepNumber
  title
  url
}

input RequestScalarWhereInput {
  AND: [RequestScalarWhereInput!]
  NOT: [RequestScalarWhereInput!]
  OR: [RequestScalarWhereInput!]
  body: JsonNullableFilter
  collectionId: IntFilter
  createdAt: DateTimeFilter
  headers: JsonNullableFilter
  id: IntFilter
  method: StringFilter
  stepNumber: IntFilter
  title: StringFilter
  url: StringFilter
}

input RequestScalarWhereWithAggregatesInput {
  AND: [RequestScalarWhereWithAggregatesInput!]
  NOT: [RequestScalarWhereWithAggregatesInput!]
  OR: [RequestScalarWhereWithAggregatesInput!]
  body: JsonNullableWithAggregatesFilter
  collectionId: IntWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  headers: JsonNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  method: StringWithAggregatesFilter
  stepNumber: IntWithAggregatesFilter
  title: StringWithAggregatesFilter
  url: StringWithAggregatesFilter
}

type RequestSumAggregate {
  collectionId: Int
  id: Int
  stepNumber: Int
}

input RequestSumOrderByAggregateInput {
  collectionId: SortOrder
  id: SortOrder
  stepNumber: SortOrder
}

input RequestUpdateInput {
  assertions: AssertionUpdateManyWithoutRequestNestedInput
  body: JSON
  collection: CollectionUpdateOneRequiredWithoutRequestsNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  headers: JSON
  method: StringFieldUpdateOperationsInput
  responses: ResponseUpdateManyWithoutRequestNestedInput
  stepNumber: IntFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
}

input RequestUpdateManyMutationInput {
  body: JSON
  createdAt: DateTimeFieldUpdateOperationsInput
  headers: JSON
  method: StringFieldUpdateOperationsInput
  stepNumber: IntFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
}

input RequestUpdateManyWithWhereWithoutCollectionInput {
  data: RequestUpdateManyMutationInput!
  where: RequestScalarWhereInput!
}

input RequestUpdateManyWithoutCollectionNestedInput {
  connect: [RequestWhereUniqueInput!]
  connectOrCreate: [RequestCreateOrConnectWithoutCollectionInput!]
  create: [RequestCreateWithoutCollectionInput!]
  createMany: RequestCreateManyCollectionInputEnvelope
  delete: [RequestWhereUniqueInput!]
  deleteMany: [RequestScalarWhereInput!]
  disconnect: [RequestWhereUniqueInput!]
  set: [RequestWhereUniqueInput!]
  update: [RequestUpdateWithWhereUniqueWithoutCollectionInput!]
  updateMany: [RequestUpdateManyWithWhereWithoutCollectionInput!]
  upsert: [RequestUpsertWithWhereUniqueWithoutCollectionInput!]
}

input RequestUpdateOneRequiredWithoutAssertionsNestedInput {
  connect: RequestWhereUniqueInput
  connectOrCreate: RequestCreateOrConnectWithoutAssertionsInput
  create: RequestCreateWithoutAssertionsInput
  update: RequestUpdateWithoutAssertionsInput
  upsert: RequestUpsertWithoutAssertionsInput
}

input RequestUpdateOneRequiredWithoutResponsesNestedInput {
  connect: RequestWhereUniqueInput
  connectOrCreate: RequestCreateOrConnectWithoutResponsesInput
  create: RequestCreateWithoutResponsesInput
  update: RequestUpdateWithoutResponsesInput
  upsert: RequestUpsertWithoutResponsesInput
}

input RequestUpdateWithWhereUniqueWithoutCollectionInput {
  data: RequestUpdateWithoutCollectionInput!
  where: RequestWhereUniqueInput!
}

input RequestUpdateWithoutAssertionsInput {
  body: JSON
  collection: CollectionUpdateOneRequiredWithoutRequestsNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  headers: JSON
  method: StringFieldUpdateOperationsInput
  responses: ResponseUpdateManyWithoutRequestNestedInput
  stepNumber: IntFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
}

input RequestUpdateWithoutCollectionInput {
  assertions: AssertionUpdateManyWithoutRequestNestedInput
  body: JSON
  createdAt: DateTimeFieldUpdateOperationsInput
  headers: JSON
  method: StringFieldUpdateOperationsInput
  responses: ResponseUpdateManyWithoutRequestNestedInput
  stepNumber: IntFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
}

input RequestUpdateWithoutResponsesInput {
  assertions: AssertionUpdateManyWithoutRequestNestedInput
  body: JSON
  collection: CollectionUpdateOneRequiredWithoutRequestsNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  headers: JSON
  method: StringFieldUpdateOperationsInput
  stepNumber: IntFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
}

input RequestUpsertWithWhereUniqueWithoutCollectionInput {
  create: RequestCreateWithoutCollectionInput!
  update: RequestUpdateWithoutCollectionInput!
  where: RequestWhereUniqueInput!
}

input RequestUpsertWithoutAssertionsInput {
  create: RequestCreateWithoutAssertionsInput!
  update: RequestUpdateWithoutAssertionsInput!
}

input RequestUpsertWithoutResponsesInput {
  create: RequestCreateWithoutResponsesInput!
  update: RequestUpdateWithoutResponsesInput!
}

input RequestWhereInput {
  AND: [RequestWhereInput!]
  NOT: [RequestWhereInput!]
  OR: [RequestWhereInput!]
  assertions: AssertionListRelationFilter
  body: JsonNullableFilter
  collection: CollectionRelationFilter
  collectionId: IntFilter
  createdAt: DateTimeFilter
  headers: JsonNullableFilter
  id: IntFilter
  method: StringFilter
  responses: ResponseListRelationFilter
  stepNumber: IntFilter
  title: StringFilter
  url: StringFilter
}

input RequestWhereUniqueInput {
  id: Int
}

type Response {
  AssertionResults(cursor: AssertionResultsWhereUniqueInput, distinct: [AssertionResultsScalarFieldEnum!], orderBy: [AssertionResultsOrderByWithRelationInput!], skip: Int, take: Int, where: AssertionResultsWhereInput): [AssertionResults!]!
  CollectionRun: CollectionRun
  _count: ResponseCount
  body: JSON
  collectionRunId: Int
  createdAt: DateTime!
  headers: JSON!
  id: Int!
  latency: Int!
  request: Request!
  requestId: Int!
  status: Int!
}

type ResponseAvgAggregate {
  collectionRunId: Float
  id: Float
  latency: Float
  requestId: Float
  status: Float
}

input ResponseAvgOrderByAggregateInput {
  collectionRunId: SortOrder
  id: SortOrder
  latency: SortOrder
  requestId: SortOrder
  status: SortOrder
}

type ResponseCount {
  AssertionResults: Int!
}

type ResponseCountAggregate {
  _all: Int!
  body: Int!
  collectionRunId: Int!
  createdAt: Int!
  headers: Int!
  id: Int!
  latency: Int!
  requestId: Int!
  status: Int!
}

input ResponseCountOrderByAggregateInput {
  body: SortOrder
  collectionRunId: SortOrder
  createdAt: SortOrder
  headers: SortOrder
  id: SortOrder
  latency: SortOrder
  requestId: SortOrder
  status: SortOrder
}

input ResponseCreateInput {
  AssertionResults: AssertionResultsCreateNestedManyWithoutResponseInput
  CollectionRun: CollectionRunCreateNestedOneWithoutResponsesInput
  body: JSON
  createdAt: DateTime
  headers: JSON!
  latency: Int!
  request: RequestCreateNestedOneWithoutResponsesInput!
  status: Int!
}

input ResponseCreateManyCollectionRunInput {
  body: JSON
  createdAt: DateTime
  headers: JSON!
  id: Int
  latency: Int!
  requestId: Int!
  status: Int!
}

input ResponseCreateManyCollectionRunInputEnvelope {
  data: [ResponseCreateManyCollectionRunInput!]!
  skipDuplicates: Boolean
}

input ResponseCreateManyInput {
  body: JSON
  collectionRunId: Int
  createdAt: DateTime
  headers: JSON!
  id: Int
  latency: Int!
  requestId: Int!
  status: Int!
}

input ResponseCreateManyRequestInput {
  body: JSON
  collectionRunId: Int
  createdAt: DateTime
  headers: JSON!
  id: Int
  latency: Int!
  status: Int!
}

input ResponseCreateManyRequestInputEnvelope {
  data: [ResponseCreateManyRequestInput!]!
  skipDuplicates: Boolean
}

input ResponseCreateNestedManyWithoutCollectionRunInput {
  connect: [ResponseWhereUniqueInput!]
  connectOrCreate: [ResponseCreateOrConnectWithoutCollectionRunInput!]
  create: [ResponseCreateWithoutCollectionRunInput!]
  createMany: ResponseCreateManyCollectionRunInputEnvelope
}

input ResponseCreateNestedManyWithoutRequestInput {
  connect: [ResponseWhereUniqueInput!]
  connectOrCreate: [ResponseCreateOrConnectWithoutRequestInput!]
  create: [ResponseCreateWithoutRequestInput!]
  createMany: ResponseCreateManyRequestInputEnvelope
}

input ResponseCreateNestedOneWithoutAssertionResultsInput {
  connect: ResponseWhereUniqueInput
  connectOrCreate: ResponseCreateOrConnectWithoutAssertionResultsInput
  create: ResponseCreateWithoutAssertionResultsInput
}

input ResponseCreateOrConnectWithoutAssertionResultsInput {
  create: ResponseCreateWithoutAssertionResultsInput!
  where: ResponseWhereUniqueInput!
}

input ResponseCreateOrConnectWithoutCollectionRunInput {
  create: ResponseCreateWithoutCollectionRunInput!
  where: ResponseWhereUniqueInput!
}

input ResponseCreateOrConnectWithoutRequestInput {
  create: ResponseCreateWithoutRequestInput!
  where: ResponseWhereUniqueInput!
}

input ResponseCreateWithoutAssertionResultsInput {
  CollectionRun: CollectionRunCreateNestedOneWithoutResponsesInput
  body: JSON
  createdAt: DateTime
  headers: JSON!
  latency: Int!
  request: RequestCreateNestedOneWithoutResponsesInput!
  status: Int!
}

input ResponseCreateWithoutCollectionRunInput {
  AssertionResults: AssertionResultsCreateNestedManyWithoutResponseInput
  body: JSON
  createdAt: DateTime
  headers: JSON!
  latency: Int!
  request: RequestCreateNestedOneWithoutResponsesInput!
  status: Int!
}

input ResponseCreateWithoutRequestInput {
  AssertionResults: AssertionResultsCreateNestedManyWithoutResponseInput
  CollectionRun: CollectionRunCreateNestedOneWithoutResponsesInput
  body: JSON
  createdAt: DateTime
  headers: JSON!
  latency: Int!
  status: Int!
}

type ResponseGroupBy {
  _avg: ResponseAvgAggregate
  _count: ResponseCountAggregate
  _max: ResponseMaxAggregate
  _min: ResponseMinAggregate
  _sum: ResponseSumAggregate
  body: JSON
  collectionRunId: Int
  createdAt: DateTime!
  headers: JSON!
  id: Int!
  latency: Int!
  requestId: Int!
  status: Int!
}

input ResponseListRelationFilter {
  every: ResponseWhereInput
  none: ResponseWhereInput
  some: ResponseWhereInput
}

type ResponseMaxAggregate {
  collectionRunId: Int
  createdAt: DateTime
  id: Int
  latency: Int
  requestId: Int
  status: Int
}

input ResponseMaxOrderByAggregateInput {
  collectionRunId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  latency: SortOrder
  requestId: SortOrder
  status: SortOrder
}

type ResponseMinAggregate {
  collectionRunId: Int
  createdAt: DateTime
  id: Int
  latency: Int
  requestId: Int
  status: Int
}

input ResponseMinOrderByAggregateInput {
  collectionRunId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  latency: SortOrder
  requestId: SortOrder
  status: SortOrder
}

input ResponseOrderByRelationAggregateInput {
  _count: SortOrder
}

input ResponseOrderByWithAggregationInput {
  _avg: ResponseAvgOrderByAggregateInput
  _count: ResponseCountOrderByAggregateInput
  _max: ResponseMaxOrderByAggregateInput
  _min: ResponseMinOrderByAggregateInput
  _sum: ResponseSumOrderByAggregateInput
  body: SortOrder
  collectionRunId: SortOrder
  createdAt: SortOrder
  headers: SortOrder
  id: SortOrder
  latency: SortOrder
  requestId: SortOrder
  status: SortOrder
}

input ResponseOrderByWithRelationInput {
  AssertionResults: AssertionResultsOrderByRelationAggregateInput
  CollectionRun: CollectionRunOrderByWithRelationInput
  body: SortOrder
  collectionRunId: SortOrder
  createdAt: SortOrder
  headers: SortOrder
  id: SortOrder
  latency: SortOrder
  request: RequestOrderByWithRelationInput
  requestId: SortOrder
  status: SortOrder
}

input ResponseRelationFilter {
  is: ResponseWhereInput
  isNot: ResponseWhereInput
}

enum ResponseScalarFieldEnum {
  body
  collectionRunId
  createdAt
  headers
  id
  latency
  requestId
  status
}

input ResponseScalarWhereInput {
  AND: [ResponseScalarWhereInput!]
  NOT: [ResponseScalarWhereInput!]
  OR: [ResponseScalarWhereInput!]
  body: JsonNullableFilter
  collectionRunId: IntNullableFilter
  createdAt: DateTimeFilter
  headers: JsonFilter
  id: IntFilter
  latency: IntFilter
  requestId: IntFilter
  status: IntFilter
}

input ResponseScalarWhereWithAggregatesInput {
  AND: [ResponseScalarWhereWithAggregatesInput!]
  NOT: [ResponseScalarWhereWithAggregatesInput!]
  OR: [ResponseScalarWhereWithAggregatesInput!]
  body: JsonNullableWithAggregatesFilter
  collectionRunId: IntNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  headers: JsonWithAggregatesFilter
  id: IntWithAggregatesFilter
  latency: IntWithAggregatesFilter
  requestId: IntWithAggregatesFilter
  status: IntWithAggregatesFilter
}

type ResponseSumAggregate {
  collectionRunId: Int
  id: Int
  latency: Int
  requestId: Int
  status: Int
}

input ResponseSumOrderByAggregateInput {
  collectionRunId: SortOrder
  id: SortOrder
  latency: SortOrder
  requestId: SortOrder
  status: SortOrder
}

input ResponseUpdateInput {
  AssertionResults: AssertionResultsUpdateManyWithoutResponseNestedInput
  CollectionRun: CollectionRunUpdateOneWithoutResponsesNestedInput
  body: JSON
  createdAt: DateTimeFieldUpdateOperationsInput
  headers: JSON
  latency: IntFieldUpdateOperationsInput
  request: RequestUpdateOneRequiredWithoutResponsesNestedInput
  status: IntFieldUpdateOperationsInput
}

input ResponseUpdateManyMutationInput {
  body: JSON
  createdAt: DateTimeFieldUpdateOperationsInput
  headers: JSON
  latency: IntFieldUpdateOperationsInput
  status: IntFieldUpdateOperationsInput
}

input ResponseUpdateManyWithWhereWithoutCollectionRunInput {
  data: ResponseUpdateManyMutationInput!
  where: ResponseScalarWhereInput!
}

input ResponseUpdateManyWithWhereWithoutRequestInput {
  data: ResponseUpdateManyMutationInput!
  where: ResponseScalarWhereInput!
}

input ResponseUpdateManyWithoutCollectionRunNestedInput {
  connect: [ResponseWhereUniqueInput!]
  connectOrCreate: [ResponseCreateOrConnectWithoutCollectionRunInput!]
  create: [ResponseCreateWithoutCollectionRunInput!]
  createMany: ResponseCreateManyCollectionRunInputEnvelope
  delete: [ResponseWhereUniqueInput!]
  deleteMany: [ResponseScalarWhereInput!]
  disconnect: [ResponseWhereUniqueInput!]
  set: [ResponseWhereUniqueInput!]
  update: [ResponseUpdateWithWhereUniqueWithoutCollectionRunInput!]
  updateMany: [ResponseUpdateManyWithWhereWithoutCollectionRunInput!]
  upsert: [ResponseUpsertWithWhereUniqueWithoutCollectionRunInput!]
}

input ResponseUpdateManyWithoutRequestNestedInput {
  connect: [ResponseWhereUniqueInput!]
  connectOrCreate: [ResponseCreateOrConnectWithoutRequestInput!]
  create: [ResponseCreateWithoutRequestInput!]
  createMany: ResponseCreateManyRequestInputEnvelope
  delete: [ResponseWhereUniqueInput!]
  deleteMany: [ResponseScalarWhereInput!]
  disconnect: [ResponseWhereUniqueInput!]
  set: [ResponseWhereUniqueInput!]
  update: [ResponseUpdateWithWhereUniqueWithoutRequestInput!]
  updateMany: [ResponseUpdateManyWithWhereWithoutRequestInput!]
  upsert: [ResponseUpsertWithWhereUniqueWithoutRequestInput!]
}

input ResponseUpdateOneRequiredWithoutAssertionResultsNestedInput {
  connect: ResponseWhereUniqueInput
  connectOrCreate: ResponseCreateOrConnectWithoutAssertionResultsInput
  create: ResponseCreateWithoutAssertionResultsInput
  update: ResponseUpdateWithoutAssertionResultsInput
  upsert: ResponseUpsertWithoutAssertionResultsInput
}

input ResponseUpdateWithWhereUniqueWithoutCollectionRunInput {
  data: ResponseUpdateWithoutCollectionRunInput!
  where: ResponseWhereUniqueInput!
}

input ResponseUpdateWithWhereUniqueWithoutRequestInput {
  data: ResponseUpdateWithoutRequestInput!
  where: ResponseWhereUniqueInput!
}

input ResponseUpdateWithoutAssertionResultsInput {
  CollectionRun: CollectionRunUpdateOneWithoutResponsesNestedInput
  body: JSON
  createdAt: DateTimeFieldUpdateOperationsInput
  headers: JSON
  latency: IntFieldUpdateOperationsInput
  request: RequestUpdateOneRequiredWithoutResponsesNestedInput
  status: IntFieldUpdateOperationsInput
}

input ResponseUpdateWithoutCollectionRunInput {
  AssertionResults: AssertionResultsUpdateManyWithoutResponseNestedInput
  body: JSON
  createdAt: DateTimeFieldUpdateOperationsInput
  headers: JSON
  latency: IntFieldUpdateOperationsInput
  request: RequestUpdateOneRequiredWithoutResponsesNestedInput
  status: IntFieldUpdateOperationsInput
}

input ResponseUpdateWithoutRequestInput {
  AssertionResults: AssertionResultsUpdateManyWithoutResponseNestedInput
  CollectionRun: CollectionRunUpdateOneWithoutResponsesNestedInput
  body: JSON
  createdAt: DateTimeFieldUpdateOperationsInput
  headers: JSON
  latency: IntFieldUpdateOperationsInput
  status: IntFieldUpdateOperationsInput
}

input ResponseUpsertWithWhereUniqueWithoutCollectionRunInput {
  create: ResponseCreateWithoutCollectionRunInput!
  update: ResponseUpdateWithoutCollectionRunInput!
  where: ResponseWhereUniqueInput!
}

input ResponseUpsertWithWhereUniqueWithoutRequestInput {
  create: ResponseCreateWithoutRequestInput!
  update: ResponseUpdateWithoutRequestInput!
  where: ResponseWhereUniqueInput!
}

input ResponseUpsertWithoutAssertionResultsInput {
  create: ResponseCreateWithoutAssertionResultsInput!
  update: ResponseUpdateWithoutAssertionResultsInput!
}

input ResponseWhereInput {
  AND: [ResponseWhereInput!]
  AssertionResults: AssertionResultsListRelationFilter
  CollectionRun: CollectionRunRelationFilter
  NOT: [ResponseWhereInput!]
  OR: [ResponseWhereInput!]
  body: JsonNullableFilter
  collectionRunId: IntNullableFilter
  createdAt: DateTimeFilter
  headers: JsonFilter
  id: IntFilter
  latency: IntFilter
  request: RequestRelationFilter
  requestId: IntFilter
  status: IntFilter
}

input ResponseWhereUniqueInput {
  id: Int
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}
